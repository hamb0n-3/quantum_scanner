/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const NDPI_USE_ASYMMETRIC_DETECTION: u32 = 0;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_IP: u32 = 1;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP: u32 = 2;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP: u32 = 4;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP: u32 = 8;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD: u32 = 16;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION: u32 = 32;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_IPV6: u32 = 64;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6: u32 = 128;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC: u32 = 256;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP: u32 = 3;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_UDP: u32 = 5;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP: u32 = 9;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP: u32 = 66;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_UDP: u32 = 68;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_OR_UDP: u32 = 72;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP: u32 = 130;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP: u32 = 132;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_OR_UDP: u32 = 136;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_WITH_PAYLOAD: u32 = 19;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_WITH_PAYLOAD: u32 = 82;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD: u32 = 146;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_UDP_WITH_PAYLOAD: u32 = 21;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_UDP_WITH_PAYLOAD: u32 = 84;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD: u32 = 148;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD: u32 = 25;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_OR_UDP_WITH_PAYLOAD: u32 = 88;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_OR_UDP_WITH_PAYLOAD: u32 = 152;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_WITHOUT_RETRANSMISSION: u32 = 35;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_WITHOUT_RETRANSMISSION: u32 = 98;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITHOUT_RETRANSMISSION: u32 = 162;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITHOUT_RETRANSMISSION: u32 = 41;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_OR_UDP_WITHOUT_RETRANSMISSION: u32 = 104;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_OR_UDP_WITHOUT_RETRANSMISSION: u32 = 168;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION: u32 = 51;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION: u32 = 114;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION: u32 = 178;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION: u32 = 57;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V6_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION: u32 =
    120;
pub const NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_OR_UDP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION:
    u32 = 184;
pub const NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE: u32 = 65536;
pub const NDPI_MAX_NUM_PKTS_PER_FLOW_TO_DISSECT: u32 = 32;
pub const NDPI_MAX_PARSE_LINES_PER_PACKET: u32 = 64;
pub const NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT: u32 = 600;
pub const NDPI_IRC_CONNECTION_TIMEOUT: u32 = 120;
pub const NDPI_GNUTELLA_CONNECTION_TIMEOUT: u32 = 60;
pub const NDPI_BATTLEFIELD_CONNECTION_TIMEOUT: u32 = 60;
pub const NDPI_THUNDER_CONNECTION_TIMEOUT: u32 = 30;
pub const NDPI_TVANTS_CONNECTION_TIMEOUT: u32 = 5;
pub const NDPI_ZATTOO_CONNECTION_TIMEOUT: u32 = 120;
pub const NDPI_ZATTOO_FLASH_TIMEOUT: u32 = 5;
pub const NDPI_JABBER_STUN_TIMEOUT: u32 = 30;
pub const NDPI_JABBER_FT_TIMEOUT: u32 = 5;
pub const NDPI_NUM_BITS: u32 = 512;
pub const NDPI_NUM_BITS_MASK: u32 = 511;
pub const NDPI_IPSEC_PROTOCOL_ESP: u32 = 50;
pub const NDPI_IPSEC_PROTOCOL_AH: u32 = 51;
pub const NDPI_GRE_PROTOCOL_TYPE: u32 = 47;
pub const NDPI_ICMP_PROTOCOL_TYPE: u32 = 1;
pub const NDPI_IGMP_PROTOCOL_TYPE: u32 = 2;
pub const NDPI_EGP_PROTOCOL_TYPE: u32 = 8;
pub const NDPI_OSPF_PROTOCOL_TYPE: u32 = 89;
pub const NDPI_SCTP_PROTOCOL_TYPE: u32 = 132;
pub const NDPI_IPIP_PROTOCOL_TYPE: u32 = 4;
pub const NDPI_ICMPV6_PROTOCOL_TYPE: u32 = 58;
pub const NDPI_MAX_DNS_REQUESTS: u32 = 16;
pub const NDPI_MIN_NUM_STUN_DETECTION: u32 = 8;
pub const NDPI_MAJOR: u32 = 4;
pub const NDPI_MINOR: u32 = 2;
pub const NDPI_PATCH: u32 = 0;
pub const NDPI_CIPHER_SAFE: u32 = 0;
pub const NDPI_CIPHER_WEAK: u32 = 1;
pub const NDPI_CIPHER_INSECURE: u32 = 2;
pub const NDPI_OPTIMAL_HLL_NUM_BUCKETS: u32 = 16;
pub const NDPI_MAX_NUM_TLS_APPL_BLOCKS: u32 = 8;
pub const NDPI_PROTOCOL_SIZE: u32 = 2;
pub const NDPI_PROTOCOL_DEFAULT_LEVEL: u32 = 0;
pub const NDPI_SERIALIZER_DEFAULT_HEADER_SIZE: u32 = 1024;
pub const NDPI_SERIALIZER_DEFAULT_BUFFER_SIZE: u32 = 8192;
pub const NDPI_SERIALIZER_DEFAULT_BUFFER_INCR: u32 = 1024;
pub const NDPI_SERIALIZER_STATUS_COMMA: u32 = 1;
pub const NDPI_SERIALIZER_STATUS_ARRAY: u32 = 2;
pub const NDPI_SERIALIZER_STATUS_EOR: u32 = 4;
pub const NDPI_SERIALIZER_STATUS_SOB: u32 = 8;
pub const NDPI_SERIALIZER_STATUS_NOT_EMPTY: u32 = 16;
pub const NDPI_SERIALIZER_STATUS_LIST: u32 = 32;
pub const NDPI_SERIALIZER_STATUS_SOL: u32 = 64;
pub const NDPI_SERIALIZER_STATUS_HDR_DONE: u32 = 128;
pub const NDPI_PROTOCOL_NO_MORE_SUBPROTOCOLS: i32 = -1;
pub const NDPI_PROTOCOL_MATCHED_BY_CONTENT: i32 = -2;
pub const NDPI_API_VERSION: u32 = 803;
pub const NDPI_DETECTION_ONLY_IPV4: u32 = 1;
pub const NDPI_DETECTION_ONLY_IPV6: u32 = 2;
pub type __u_char = libc::c_uchar;
pub type __u_int = libc::c_uint;
pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type u_char = __u_char;
pub type u_int = __u_int;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::core::mem::MaybeUninit<in_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::core::mem::MaybeUninit<in6_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__in6_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UNKNOWN: ndpi_protocol_id_t = 0;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FTP_CONTROL: ndpi_protocol_id_t = 1;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_POP: ndpi_protocol_id_t = 2;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_SMTP: ndpi_protocol_id_t = 3;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_IMAP: ndpi_protocol_id_t = 4;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DNS: ndpi_protocol_id_t = 5;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IPP: ndpi_protocol_id_t = 6;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP: ndpi_protocol_id_t = 7;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MDNS: ndpi_protocol_id_t = 8;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NTP: ndpi_protocol_id_t = 9;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETBIOS: ndpi_protocol_id_t = 10;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NFS: ndpi_protocol_id_t = 11;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SSDP: ndpi_protocol_id_t = 12;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BGP: ndpi_protocol_id_t = 13;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SNMP: ndpi_protocol_id_t = 14;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_XDMCP: ndpi_protocol_id_t = 15;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SMBV1: ndpi_protocol_id_t = 16;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SYSLOG: ndpi_protocol_id_t = 17;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DHCP: ndpi_protocol_id_t = 18;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_POSTGRES: ndpi_protocol_id_t = 19;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MYSQL: ndpi_protocol_id_t = 20;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HOTMAIL: ndpi_protocol_id_t = 21;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK: ndpi_protocol_id_t = 22;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_POPS: ndpi_protocol_id_t = 23;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLEJUICE: ndpi_protocol_id_t = 24;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DIRECTCONNECT: ndpi_protocol_id_t = 25;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NTOP: ndpi_protocol_id_t = 26;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_COAP: ndpi_protocol_id_t = 27;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VMWARE: ndpi_protocol_id_t = 28;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_SMTPS: ndpi_protocol_id_t = 29;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DTLS: ndpi_protocol_id_t = 30;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UBNTAC2: ndpi_protocol_id_t = 31;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KONTIKI: ndpi_protocol_id_t = 32;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENFT: ndpi_protocol_id_t = 33;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FASTTRACK: ndpi_protocol_id_t = 34;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GNUTELLA: ndpi_protocol_id_t = 35;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EDONKEY: ndpi_protocol_id_t = 36;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BITTORRENT: ndpi_protocol_id_t = 37;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SKYPE_CALL: ndpi_protocol_id_t = 38;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIGNAL: ndpi_protocol_id_t = 39;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MEMCACHED: ndpi_protocol_id_t = 40;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SMBV23: ndpi_protocol_id_t = 41;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MINING: ndpi_protocol_id_t = 42;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NEST_LOG_SINK: ndpi_protocol_id_t = 43;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MODBUS: ndpi_protocol_id_t = 44;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHATSAPP_CALL: ndpi_protocol_id_t = 45;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DATASAVER: ndpi_protocol_id_t = 46;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_XBOX: ndpi_protocol_id_t = 47;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_QQ: ndpi_protocol_id_t = 48;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TIKTOK: ndpi_protocol_id_t = 49;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTSP: ndpi_protocol_id_t = 50;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAIL_IMAPS: ndpi_protocol_id_t = 51;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ICECAST: ndpi_protocol_id_t = 52;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CPHA: ndpi_protocol_id_t = 53;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PPSTREAM: ndpi_protocol_id_t = 54;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZATTOO: ndpi_protocol_id_t = 55;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SHOUTCAST: ndpi_protocol_id_t = 56;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOPCAST: ndpi_protocol_id_t = 57;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DISCORD: ndpi_protocol_id_t = 58;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TVUPLAYER: ndpi_protocol_id_t = 59;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MONGODB: ndpi_protocol_id_t = 60;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_QQLIVE: ndpi_protocol_id_t = 61;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_THUNDER: ndpi_protocol_id_t = 62;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OCSP: ndpi_protocol_id_t = 63;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FREE_64: ndpi_protocol_id_t = 64;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IRC: ndpi_protocol_id_t = 65;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AYIYA: ndpi_protocol_id_t = 66;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_JABBER: ndpi_protocol_id_t = 67;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NATS: ndpi_protocol_id_t = 68;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMONG_US: ndpi_protocol_id_t = 69;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YAHOO: ndpi_protocol_id_t = 70;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DISNEYPLUS: ndpi_protocol_id_t = 71;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_PLUS: ndpi_protocol_id_t = 72;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_VRRP: ndpi_protocol_id_t = 73;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STEAM: ndpi_protocol_id_t = 74;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HALFLIFE2: ndpi_protocol_id_t = 75;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WORLDOFWARCRAFT: ndpi_protocol_id_t = 76;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TELNET: ndpi_protocol_id_t = 77;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STUN: ndpi_protocol_id_t = 78;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_IPSEC: ndpi_protocol_id_t = 79;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_GRE: ndpi_protocol_id_t = 80;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_ICMP: ndpi_protocol_id_t = 81;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_IGMP: ndpi_protocol_id_t = 82;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_EGP: ndpi_protocol_id_t = 83;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_SCTP: ndpi_protocol_id_t = 84;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_OSPF: ndpi_protocol_id_t = 85;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_IP_IN_IP: ndpi_protocol_id_t = 86;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTP: ndpi_protocol_id_t = 87;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RDP: ndpi_protocol_id_t = 88;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VNC: ndpi_protocol_id_t = 89;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TUMBLR: ndpi_protocol_id_t = 90;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TLS: ndpi_protocol_id_t = 91;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SSH: ndpi_protocol_id_t = 92;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_USENET: ndpi_protocol_id_t = 93;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MGCP: ndpi_protocol_id_t = 94;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IAX: ndpi_protocol_id_t = 95;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TFTP: ndpi_protocol_id_t = 96;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AFP: ndpi_protocol_id_t = 97;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STEALTHNET: ndpi_protocol_id_t = 98;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AIMINI: ndpi_protocol_id_t = 99;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIP: ndpi_protocol_id_t = 100;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TRUPHONE: ndpi_protocol_id_t = 101;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IP_ICMPV6: ndpi_protocol_id_t = 102;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DHCPV6: ndpi_protocol_id_t = 103;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ARMAGETRON: ndpi_protocol_id_t = 104;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CROSSFIRE: ndpi_protocol_id_t = 105;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DOFUS: ndpi_protocol_id_t = 106;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FIESTA: ndpi_protocol_id_t = 107;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FLORENSIA: ndpi_protocol_id_t = 108;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GUILDWARS: ndpi_protocol_id_t = 109;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON_ALEXA: ndpi_protocol_id_t = 110;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KERBEROS: ndpi_protocol_id_t = 111;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LDAP: ndpi_protocol_id_t = 112;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MAPLESTORY: ndpi_protocol_id_t = 113;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MSSQL_TDS: ndpi_protocol_id_t = 114;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PPTP: ndpi_protocol_id_t = 115;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WARCRAFT3: ndpi_protocol_id_t = 116;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WORLD_OF_KUNG_FU: ndpi_protocol_id_t = 117;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SLACK: ndpi_protocol_id_t = 118;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FACEBOOK: ndpi_protocol_id_t = 119;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TWITTER: ndpi_protocol_id_t = 120;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DROPBOX: ndpi_protocol_id_t = 121;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GMAIL: ndpi_protocol_id_t = 122;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_MAPS: ndpi_protocol_id_t = 123;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YOUTUBE: ndpi_protocol_id_t = 124;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SKYPE_TEAMS: ndpi_protocol_id_t = 125;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE: ndpi_protocol_id_t = 126;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DCERPC: ndpi_protocol_id_t = 127;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETFLOW: ndpi_protocol_id_t = 128;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SFLOW: ndpi_protocol_id_t = 129;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP_CONNECT: ndpi_protocol_id_t = 130;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HTTP_PROXY: ndpi_protocol_id_t = 131;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CITRIX: ndpi_protocol_id_t = 132;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NETFLIX: ndpi_protocol_id_t = 133;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LASTFM: ndpi_protocol_id_t = 134;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WAZE: ndpi_protocol_id_t = 135;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_YOUTUBE_UPLOAD: ndpi_protocol_id_t = 136;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HULU: ndpi_protocol_id_t = 137;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CHECKMK: ndpi_protocol_id_t = 138;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AJP: ndpi_protocol_id_t = 139;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE: ndpi_protocol_id_t = 140;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WEBEX: ndpi_protocol_id_t = 141;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHATSAPP: ndpi_protocol_id_t = 142;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_ICLOUD: ndpi_protocol_id_t = 143;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VIBER: ndpi_protocol_id_t = 144;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_ITUNES: ndpi_protocol_id_t = 145;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RADIUS: ndpi_protocol_id_t = 146;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WINDOWS_UPDATE: ndpi_protocol_id_t = 147;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEAMVIEWER: ndpi_protocol_id_t = 148;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TUENTI: ndpi_protocol_id_t = 149;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LOTUS_NOTES: ndpi_protocol_id_t = 150;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SAP: ndpi_protocol_id_t = 151;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP: ndpi_protocol_id_t = 152;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WSD: ndpi_protocol_id_t = 153;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LLMNR: ndpi_protocol_id_t = 154;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_REMOTE_SCAN: ndpi_protocol_id_t = 155;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SPOTIFY: ndpi_protocol_id_t = 156;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MESSENGER: ndpi_protocol_id_t = 157;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_H323: ndpi_protocol_id_t = 158;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENVPN: ndpi_protocol_id_t = 159;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NOE: ndpi_protocol_id_t = 160;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CISCOVPN: ndpi_protocol_id_t = 161;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEAMSPEAK: ndpi_protocol_id_t = 162;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TOR: ndpi_protocol_id_t = 163;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SKINNY: ndpi_protocol_id_t = 164;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTCP: ndpi_protocol_id_t = 165;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RSYNC: ndpi_protocol_id_t = 166;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ORACLE: ndpi_protocol_id_t = 167;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CORBA: ndpi_protocol_id_t = 168;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_UBUNTUONE: ndpi_protocol_id_t = 169;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHOIS_DAS: ndpi_protocol_id_t = 170;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_COLLECTD: ndpi_protocol_id_t = 171;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOCKS: ndpi_protocol_id_t = 172;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_NINTENDO: ndpi_protocol_id_t = 173;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RTMP: ndpi_protocol_id_t = 174;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FTP_DATA: ndpi_protocol_id_t = 175;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WIKIPEDIA: ndpi_protocol_id_t = 176;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZMQ: ndpi_protocol_id_t = 177;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON: ndpi_protocol_id_t = 178;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EBAY: ndpi_protocol_id_t = 179;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CNN: ndpi_protocol_id_t = 180;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MEGACO: ndpi_protocol_id_t = 181;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_REDIS: ndpi_protocol_id_t = 182;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PINTEREST: ndpi_protocol_id_t = 183;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VHUA: ndpi_protocol_id_t = 184;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TELEGRAM: ndpi_protocol_id_t = 185;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VEVO: ndpi_protocol_id_t = 186;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PANDORA: ndpi_protocol_id_t = 187;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_QUIC: ndpi_protocol_id_t = 188;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZOOM: ndpi_protocol_id_t = 189;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_EAQ: ndpi_protocol_id_t = 190;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OOKLA: ndpi_protocol_id_t = 191;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMQP: ndpi_protocol_id_t = 192;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KAKAOTALK: ndpi_protocol_id_t = 193;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_KAKAOTALK_VOICE: ndpi_protocol_id_t = 194;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TWITCH: ndpi_protocol_id_t = 195;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DOH_DOT: ndpi_protocol_id_t = 196;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WECHAT: ndpi_protocol_id_t = 197;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MPEGTS: ndpi_protocol_id_t = 198;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SNAPCHAT: ndpi_protocol_id_t = 199;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SINA: ndpi_protocol_id_t = 200;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HANGOUT_DUO: ndpi_protocol_id_t = 201;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IFLIX: ndpi_protocol_id_t = 202;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GITHUB: ndpi_protocol_id_t = 203;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BJNP: ndpi_protocol_id_t = 204;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_REDDIT: ndpi_protocol_id_t = 205;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WIREGUARD: ndpi_protocol_id_t = 206;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SMPP: ndpi_protocol_id_t = 207;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DNSCRYPT: ndpi_protocol_id_t = 208;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TINC: ndpi_protocol_id_t = 209;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DEEZER: ndpi_protocol_id_t = 210;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_INSTAGRAM: ndpi_protocol_id_t = 211;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MICROSOFT: ndpi_protocol_id_t = 212;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_STARCRAFT: ndpi_protocol_id_t = 213;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TEREDO: ndpi_protocol_id_t = 214;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HOTSPOT_SHIELD: ndpi_protocol_id_t = 215;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IMO: ndpi_protocol_id_t = 216;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_DRIVE: ndpi_protocol_id_t = 217;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OCS: ndpi_protocol_id_t = 218;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MICROSOFT_365: ndpi_protocol_id_t = 219;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CLOUDFLARE: ndpi_protocol_id_t = 220;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MS_ONE_DRIVE: ndpi_protocol_id_t = 221;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MQTT: ndpi_protocol_id_t = 222;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_RX: ndpi_protocol_id_t = 223;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLESTORE: ndpi_protocol_id_t = 224;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_OPENDNS: ndpi_protocol_id_t = 225;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GIT: ndpi_protocol_id_t = 226;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DRDA: ndpi_protocol_id_t = 227;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PLAYSTORE: ndpi_protocol_id_t = 228;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOMEIP: ndpi_protocol_id_t = 229;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FIX: ndpi_protocol_id_t = 230;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PLAYSTATION: ndpi_protocol_id_t = 231;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_PASTEBIN: ndpi_protocol_id_t = 232;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LINKEDIN: ndpi_protocol_id_t = 233;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOUNDCLOUD: ndpi_protocol_id_t = 234;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CSGO: ndpi_protocol_id_t = 235;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LISP: ndpi_protocol_id_t = 236;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DIAMETER: ndpi_protocol_id_t = 237;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_PUSH: ndpi_protocol_id_t = 238;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_SERVICES: ndpi_protocol_id_t = 239;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON_VIDEO: ndpi_protocol_id_t = 240;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_DOCS: ndpi_protocol_id_t = 241;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WHATSAPP_FILES: ndpi_protocol_id_t = 242;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_TARGUS_GETDATA: ndpi_protocol_id_t = 243;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_DNP3: ndpi_protocol_id_t = 244;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_IEC60870: ndpi_protocol_id_t = 245;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BLOOMBERG: ndpi_protocol_id_t = 246;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CAPWAP: ndpi_protocol_id_t = 247;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ZABBIX: ndpi_protocol_id_t = 248;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_S7COMM: ndpi_protocol_id_t = 249;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MSTEAMS: ndpi_protocol_id_t = 250;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_WEBSOCKET: ndpi_protocol_id_t = 251;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ANYDESK: ndpi_protocol_id_t = 252;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SOAP: ndpi_protocol_id_t = 253;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_APPLE_SIRI: ndpi_protocol_id_t = 254;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SNAPCHAT_CALL: ndpi_protocol_id_t = 255;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_HPVIRTGRP: ndpi_protocol_id_t = 256;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GENSHIN_IMPACT: ndpi_protocol_id_t = 257;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ACTIVISION: ndpi_protocol_id_t = 258;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FORTICLIENT: ndpi_protocol_id_t = 259;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_Z3950: ndpi_protocol_id_t = 260;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_LIKEE: ndpi_protocol_id_t = 261;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GITLAB: ndpi_protocol_id_t = 262;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AVAST_SECUREDNS: ndpi_protocol_id_t = 263;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CASSANDRA: ndpi_protocol_id_t = 264;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_AMAZON_AWS: ndpi_protocol_id_t = 265;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SALESFORCE: ndpi_protocol_id_t = 266;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_VIMEO: ndpi_protocol_id_t = 267;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FACEBOOK_VOIP: ndpi_protocol_id_t = 268;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_SIGNAL_VOIP: ndpi_protocol_id_t = 269;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_FUZE: ndpi_protocol_id_t = 270;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP_U: ndpi_protocol_id_t = 271;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP_C: ndpi_protocol_id_t = 272;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GTP_PRIME: ndpi_protocol_id_t = 273;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ALIBABA: ndpi_protocol_id_t = 274;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_CRASHLYSTICS: ndpi_protocol_id_t = 275;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_MICROSOFT_AZURE: ndpi_protocol_id_t = 276;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ICLOUD_PRIVATE_RELAY: ndpi_protocol_id_t = 277;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ETHERNET_IP: ndpi_protocol_id_t = 278;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_BADOO: ndpi_protocol_id_t = 279;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_ACCUWEATHER: ndpi_protocol_id_t = 280;
pub const ndpi_protocol_id_t_NDPI_PROTOCOL_GOOGLE_CLASSROOM: ndpi_protocol_id_t = 281;
pub const ndpi_protocol_id_t_NDPI_LAST_IMPLEMENTED_PROTOCOL: ndpi_protocol_id_t = 282;
pub type ndpi_protocol_id_t = libc::c_uint;
extern "C" {
    pub fn ndpi_ends_with(str_: *mut libc::c_char, ends: *mut libc::c_char) -> u_int8_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_patricia_node_value_t {
    pub u: ndpi_patricia_node_value_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_patricia_node_value_t__bindgen_ty_1 {
    pub uv32: ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1,
    pub uv64: u_int64_t,
    pub user_data: *mut libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1 {
    pub user_value: u_int32_t,
    pub additional_user_value: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(user_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).additional_user_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(additional_user_value)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_patricia_node_value_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_patricia_node_value_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_patricia_node_value_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_patricia_node_value_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uv32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1),
            "::",
            stringify!(uv32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uv64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1),
            "::",
            stringify!(uv64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_patricia_node_value_t__bindgen_ty_1),
            "::",
            stringify!(user_data)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_patricia_node_value_t() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_patricia_node_value_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_patricia_node_value_t>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_patricia_node_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_patricia_node_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_patricia_node_value_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_patricia_node_value_t),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ndpi_prefix_t {
    pub family: u_int16_t,
    pub bitlen: u_int16_t,
    pub ref_count: libc::c_int,
    pub add: _ndpi_prefix_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ndpi_prefix_t__bindgen_ty_1 {
    pub sin: in_addr,
    pub sin6: in6_addr,
    pub mac: [u_int8_t; 6usize],
}
#[test]
fn bindgen_test_layout__ndpi_prefix_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ndpi_prefix_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ndpi_prefix_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_ndpi_prefix_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ndpi_prefix_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ndpi_prefix_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t__bindgen_ty_1),
            "::",
            stringify!(sin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t__bindgen_ty_1),
            "::",
            stringify!(sin6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t__bindgen_ty_1),
            "::",
            stringify!(mac)
        )
    );
}
#[test]
fn bindgen_test_layout__ndpi_prefix_t() {
    const UNINIT: ::core::mem::MaybeUninit<_ndpi_prefix_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ndpi_prefix_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ndpi_prefix_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_ndpi_prefix_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ndpi_prefix_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitlen) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t),
            "::",
            stringify!(bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_prefix_t),
            "::",
            stringify!(add)
        )
    );
}
pub type ndpi_prefix_t = _ndpi_prefix_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ndpi_patricia_node_t {
    pub bit: u_int16_t,
    pub prefix: *mut ndpi_prefix_t,
    pub l: *mut _ndpi_patricia_node_t,
    pub r: *mut _ndpi_patricia_node_t,
    pub parent: *mut _ndpi_patricia_node_t,
    pub data: *mut libc::c_void,
    pub value: ndpi_patricia_node_value_t,
}
#[test]
fn bindgen_test_layout__ndpi_patricia_node_t() {
    const UNINIT: ::core::mem::MaybeUninit<_ndpi_patricia_node_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ndpi_patricia_node_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ndpi_patricia_node_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_ndpi_patricia_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ndpi_patricia_node_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_node_t),
            "::",
            stringify!(value)
        )
    );
}
pub type ndpi_patricia_node_t = _ndpi_patricia_node_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ndpi_patricia_tree_t {
    pub head: *mut ndpi_patricia_node_t,
    pub maxbits: u_int16_t,
    pub num_active_node: libc::c_int,
}
#[test]
fn bindgen_test_layout__ndpi_patricia_tree_t() {
    const UNINIT: ::core::mem::MaybeUninit<_ndpi_patricia_tree_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ndpi_patricia_tree_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ndpi_patricia_tree_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_ndpi_patricia_tree_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ndpi_patricia_tree_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_tree_t),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxbits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_tree_t),
            "::",
            stringify!(maxbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_active_node) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_patricia_tree_t),
            "::",
            stringify!(num_active_node)
        )
    );
}
pub type ndpi_patricia_tree_t = _ndpi_patricia_tree_t;
pub const ndpi_log_level_t_NDPI_LOG_ERROR: ndpi_log_level_t = 0;
pub const ndpi_log_level_t_NDPI_LOG_TRACE: ndpi_log_level_t = 1;
pub const ndpi_log_level_t_NDPI_LOG_DEBUG: ndpi_log_level_t = 2;
pub const ndpi_log_level_t_NDPI_LOG_DEBUG_EXTRA: ndpi_log_level_t = 3;
pub type ndpi_log_level_t = libc::c_uint;
pub const ndpi_l4_proto_info_ndpi_l4_proto_unknown: ndpi_l4_proto_info = 0;
pub const ndpi_l4_proto_info_ndpi_l4_proto_tcp_only: ndpi_l4_proto_info = 1;
pub const ndpi_l4_proto_info_ndpi_l4_proto_udp_only: ndpi_l4_proto_info = 2;
pub const ndpi_l4_proto_info_ndpi_l4_proto_tcp_and_udp: ndpi_l4_proto_info = 3;
pub type ndpi_l4_proto_info = libc::c_uint;
pub const ndpi_packet_tunnel_ndpi_no_tunnel: ndpi_packet_tunnel = 0;
pub const ndpi_packet_tunnel_ndpi_gtp_tunnel: ndpi_packet_tunnel = 1;
pub const ndpi_packet_tunnel_ndpi_capwap_tunnel: ndpi_packet_tunnel = 2;
pub const ndpi_packet_tunnel_ndpi_tzsp_tunnel: ndpi_packet_tunnel = 3;
pub const ndpi_packet_tunnel_ndpi_l2tp_tunnel: ndpi_packet_tunnel = 4;
pub const ndpi_packet_tunnel_ndpi_vxlan_tunnel: ndpi_packet_tunnel = 5;
pub type ndpi_packet_tunnel = libc::c_uint;
pub const ndpi_risk_enum_NDPI_NO_RISK: ndpi_risk_enum = 0;
pub const ndpi_risk_enum_NDPI_URL_POSSIBLE_XSS: ndpi_risk_enum = 1;
pub const ndpi_risk_enum_NDPI_URL_POSSIBLE_SQL_INJECTION: ndpi_risk_enum = 2;
pub const ndpi_risk_enum_NDPI_URL_POSSIBLE_RCE_INJECTION: ndpi_risk_enum = 3;
pub const ndpi_risk_enum_NDPI_BINARY_APPLICATION_TRANSFER: ndpi_risk_enum = 4;
pub const ndpi_risk_enum_NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT: ndpi_risk_enum = 5;
pub const ndpi_risk_enum_NDPI_TLS_SELFSIGNED_CERTIFICATE: ndpi_risk_enum = 6;
pub const ndpi_risk_enum_NDPI_TLS_OBSOLETE_VERSION: ndpi_risk_enum = 7;
pub const ndpi_risk_enum_NDPI_TLS_WEAK_CIPHER: ndpi_risk_enum = 8;
pub const ndpi_risk_enum_NDPI_TLS_CERTIFICATE_EXPIRED: ndpi_risk_enum = 9;
pub const ndpi_risk_enum_NDPI_TLS_CERTIFICATE_MISMATCH: ndpi_risk_enum = 10;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_USER_AGENT: ndpi_risk_enum = 11;
pub const ndpi_risk_enum_NDPI_HTTP_NUMERIC_IP_HOST: ndpi_risk_enum = 12;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_URL: ndpi_risk_enum = 13;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_HEADER: ndpi_risk_enum = 14;
pub const ndpi_risk_enum_NDPI_TLS_NOT_CARRYING_HTTPS: ndpi_risk_enum = 15;
pub const ndpi_risk_enum_NDPI_SUSPICIOUS_DGA_DOMAIN: ndpi_risk_enum = 16;
pub const ndpi_risk_enum_NDPI_MALFORMED_PACKET: ndpi_risk_enum = 17;
pub const ndpi_risk_enum_NDPI_SSH_OBSOLETE_CLIENT_VERSION_OR_CIPHER: ndpi_risk_enum = 18;
pub const ndpi_risk_enum_NDPI_SSH_OBSOLETE_SERVER_VERSION_OR_CIPHER: ndpi_risk_enum = 19;
pub const ndpi_risk_enum_NDPI_SMB_INSECURE_VERSION: ndpi_risk_enum = 20;
pub const ndpi_risk_enum_NDPI_TLS_SUSPICIOUS_ESNI_USAGE: ndpi_risk_enum = 21;
pub const ndpi_risk_enum_NDPI_UNSAFE_PROTOCOL: ndpi_risk_enum = 22;
pub const ndpi_risk_enum_NDPI_DNS_SUSPICIOUS_TRAFFIC: ndpi_risk_enum = 23;
pub const ndpi_risk_enum_NDPI_TLS_MISSING_SNI: ndpi_risk_enum = 24;
pub const ndpi_risk_enum_NDPI_HTTP_SUSPICIOUS_CONTENT: ndpi_risk_enum = 25;
pub const ndpi_risk_enum_NDPI_RISKY_ASN: ndpi_risk_enum = 26;
pub const ndpi_risk_enum_NDPI_RISKY_DOMAIN: ndpi_risk_enum = 27;
pub const ndpi_risk_enum_NDPI_MALICIOUS_JA3: ndpi_risk_enum = 28;
pub const ndpi_risk_enum_NDPI_MALICIOUS_SHA1_CERTIFICATE: ndpi_risk_enum = 29;
pub const ndpi_risk_enum_NDPI_DESKTOP_OR_FILE_SHARING_SESSION: ndpi_risk_enum = 30;
pub const ndpi_risk_enum_NDPI_TLS_UNCOMMON_ALPN: ndpi_risk_enum = 31;
pub const ndpi_risk_enum_NDPI_TLS_CERT_VALIDITY_TOO_LONG: ndpi_risk_enum = 32;
pub const ndpi_risk_enum_NDPI_TLS_SUSPICIOUS_EXTENSION: ndpi_risk_enum = 33;
pub const ndpi_risk_enum_NDPI_TLS_FATAL_ALERT: ndpi_risk_enum = 34;
pub const ndpi_risk_enum_NDPI_SUSPICIOUS_ENTROPY: ndpi_risk_enum = 35;
pub const ndpi_risk_enum_NDPI_CLEAR_TEXT_CREDENTIALS: ndpi_risk_enum = 36;
pub const ndpi_risk_enum_NDPI_DNS_LARGE_PACKET: ndpi_risk_enum = 37;
pub const ndpi_risk_enum_NDPI_DNS_FRAGMENTED: ndpi_risk_enum = 38;
pub const ndpi_risk_enum_NDPI_INVALID_CHARACTERS: ndpi_risk_enum = 39;
pub const ndpi_risk_enum_NDPI_POSSIBLE_EXPLOIT: ndpi_risk_enum = 40;
pub const ndpi_risk_enum_NDPI_TLS_CERTIFICATE_ABOUT_TO_EXPIRE: ndpi_risk_enum = 41;
pub const ndpi_risk_enum_NDPI_MAX_RISK: ndpi_risk_enum = 42;
pub type ndpi_risk_enum = libc::c_uint;
pub type ndpi_risk = u_int64_t;
pub const ndpi_risk_severity_NDPI_RISK_LOW: ndpi_risk_severity = 0;
pub const ndpi_risk_severity_NDPI_RISK_MEDIUM: ndpi_risk_severity = 1;
pub const ndpi_risk_severity_NDPI_RISK_HIGH: ndpi_risk_severity = 2;
pub const ndpi_risk_severity_NDPI_RISK_SEVERE: ndpi_risk_severity = 3;
pub type ndpi_risk_severity = libc::c_uint;
pub const ndpi_risk_score_NDPI_SCORE_RISK_LOW: ndpi_risk_score = 10;
pub const ndpi_risk_score_NDPI_SCORE_RISK_MEDIUM: ndpi_risk_score = 50;
pub const ndpi_risk_score_NDPI_SCORE_RISK_HIGH: ndpi_risk_score = 100;
pub const ndpi_risk_score_NDPI_SCORE_RISK_SEVERE: ndpi_risk_score = 250;
pub type ndpi_risk_score = libc::c_uint;
pub const risk_percentage_CLIENT_NO_RISK_PERCENTAGE: risk_percentage = 0;
pub const risk_percentage_CLIENT_LOW_RISK_PERCENTAGE: risk_percentage = 10;
pub const risk_percentage_CLIENT_FAIR_RISK_PERCENTAGE: risk_percentage = 50;
pub const risk_percentage_CLIENT_HIGH_RISK_PERCENTAGE: risk_percentage = 90;
pub const risk_percentage_CLIENT_FULL_RISK_PERCENTAGE: risk_percentage = 100;
pub type risk_percentage = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_risk_info {
    pub risk: ndpi_risk_enum,
    pub severity: ndpi_risk_severity,
    pub default_client_risk_pctg: risk_percentage,
}
#[test]
fn bindgen_test_layout_ndpi_risk_info() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_risk_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_risk_info>(),
        12usize,
        concat!("Size of: ", stringify!(ndpi_risk_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_risk_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_risk_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).risk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_risk_info),
            "::",
            stringify!(risk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).severity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_risk_info),
            "::",
            stringify!(severity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_client_risk_pctg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_risk_info),
            "::",
            stringify!(default_client_risk_pctg)
        )
    );
}
pub const ndpi_VISIT_ndpi_preorder: ndpi_VISIT = 0;
pub const ndpi_VISIT_ndpi_postorder: ndpi_VISIT = 1;
pub const ndpi_VISIT_ndpi_endorder: ndpi_VISIT = 2;
pub const ndpi_VISIT_ndpi_leaf: ndpi_VISIT = 3;
pub type ndpi_VISIT = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct node_t {
    pub key: *mut libc::c_char,
    pub left: *mut node_t,
    pub right: *mut node_t,
}
#[test]
fn bindgen_test_layout_node_t() {
    const UNINIT: ::core::mem::MaybeUninit<node_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<node_t>(),
        24usize,
        concat!("Size of: ", stringify!(node_t))
    );
    assert_eq!(
        ::core::mem::align_of::<node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(node_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(node_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(node_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(node_t),
            "::",
            stringify!(right)
        )
    );
}
pub type ndpi_node = node_t;
pub type ndpi_ndpi_mask = u_int32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_protocol_bitmask_struct {
    pub fds_bits: [ndpi_ndpi_mask; 16usize],
}
#[test]
fn bindgen_test_layout_ndpi_protocol_bitmask_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_protocol_bitmask_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_protocol_bitmask_struct>(),
        64usize,
        concat!("Size of: ", stringify!(ndpi_protocol_bitmask_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_protocol_bitmask_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_protocol_bitmask_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_bitmask_struct),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type ndpi_protocol_bitmask_struct_t = ndpi_protocol_bitmask_struct;
pub type ndpi_debug_function_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        protocol: u_int32_t,
        module_struct: *mut libc::c_void,
        log_level: ndpi_log_level_t,
        file: *const libc::c_char,
        func: *const libc::c_char,
        line: libc::c_uint,
        format: *const libc::c_char,
        ...
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_chdlc {
    pub addr: u_int8_t,
    pub ctrl: u_int8_t,
    pub proto_code: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_chdlc() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_chdlc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_chdlc>(),
        4usize,
        concat!("Size of: ", stringify!(ndpi_chdlc))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_chdlc>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_chdlc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_chdlc),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_chdlc),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proto_code) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_chdlc),
            "::",
            stringify!(proto_code)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_slarp {
    pub slarp_type: u_int32_t,
    pub addr_1: u_int32_t,
    pub addr_2: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_slarp() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_slarp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_slarp>(),
        12usize,
        concat!("Size of: ", stringify!(ndpi_slarp))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_slarp>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_slarp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slarp_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_slarp),
            "::",
            stringify!(slarp_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_slarp),
            "::",
            stringify!(addr_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_slarp),
            "::",
            stringify!(addr_2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_cdp {
    pub version: u_int8_t,
    pub ttl: u_int8_t,
    pub checksum: u_int16_t,
    pub type_: u_int16_t,
    pub length: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_cdp() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_cdp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_cdp>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_cdp))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_cdp>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_cdp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_cdp),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_cdp),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_cdp),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_cdp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_cdp),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ethhdr {
    pub h_dest: [u_char; 6usize],
    pub h_source: [u_char; 6usize],
    pub h_proto: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_ethhdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ethhdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ethhdr>(),
        14usize,
        concat!("Size of: ", stringify!(ndpi_ethhdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ethhdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_ethhdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_dest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ethhdr),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_source) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ethhdr),
            "::",
            stringify!(h_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_proto) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ethhdr),
            "::",
            stringify!(h_proto)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_arphdr {
    pub ar_hrd: u_int16_t,
    pub ar_pro: u_int16_t,
    pub ar_hln: u_int8_t,
    pub ar_pln: u_int8_t,
    pub ar_op: u_int16_t,
    pub arp_sha: [u_char; 6usize],
    pub arp_spa: u_int32_t,
    pub arp_tha: [u_char; 6usize],
    pub arp_tpa: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_arphdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_arphdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_arphdr>(),
        28usize,
        concat!("Size of: ", stringify!(ndpi_arphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_arphdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_arphdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_hrd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(ar_hrd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_pro) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(ar_pro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_hln) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(ar_hln)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_pln) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(ar_pln)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_op) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(ar_op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arp_sha) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(arp_sha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arp_spa) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(arp_spa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arp_tha) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(arp_tha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arp_tpa) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_arphdr),
            "::",
            stringify!(arp_tpa)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_dhcphdr {
    pub msgType: u_int8_t,
    pub htype: u_int8_t,
    pub hlen: u_int8_t,
    pub hops: u_int8_t,
    pub xid: u_int32_t,
    pub secs: u_int16_t,
    pub flags: u_int16_t,
    pub ciaddr: u_int32_t,
    pub yiaddr: u_int32_t,
    pub siaddr: u_int32_t,
    pub giaddr: u_int32_t,
    pub chaddr: [u_int8_t; 16usize],
    pub sname: [u_int8_t; 64usize],
    pub file: [u_int8_t; 128usize],
    pub magic: u_int32_t,
    pub options: [u_int8_t; 308usize],
}
#[test]
fn bindgen_test_layout_ndpi_dhcphdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_dhcphdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_dhcphdr>(),
        548usize,
        concat!("Size of: ", stringify!(ndpi_dhcphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_dhcphdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_dhcphdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(msgType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).htype) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hlen) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(hlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hops) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(hops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(xid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciaddr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(ciaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yiaddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(yiaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).siaddr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(siaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).giaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(giaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chaddr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(chaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sname) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(sname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dhcphdr),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_mdns_rsp_entry {
    pub rsp_type: u_int16_t,
    pub rsp_class: u_int16_t,
    pub ttl: u_int32_t,
    pub data_len: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_mdns_rsp_entry() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_mdns_rsp_entry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_mdns_rsp_entry>(),
        10usize,
        concat!("Size of: ", stringify!(ndpi_mdns_rsp_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_mdns_rsp_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_mdns_rsp_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_mdns_rsp_entry),
            "::",
            stringify!(rsp_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp_class) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_mdns_rsp_entry),
            "::",
            stringify!(rsp_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_mdns_rsp_entry),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_mdns_rsp_entry),
            "::",
            stringify!(data_len)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_snap_extension {
    pub oui: u_int16_t,
    pub oui2: u_int8_t,
    pub proto_ID: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_snap_extension() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_snap_extension> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_snap_extension>(),
        5usize,
        concat!("Size of: ", stringify!(ndpi_snap_extension))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_snap_extension>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_snap_extension))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oui) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_snap_extension),
            "::",
            stringify!(oui)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oui2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_snap_extension),
            "::",
            stringify!(oui2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proto_ID) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_snap_extension),
            "::",
            stringify!(proto_ID)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_llc_header_snap {
    pub dsap: u_int8_t,
    pub ssap: u_int8_t,
    pub ctrl: u_int8_t,
    pub snap: ndpi_snap_extension,
}
#[test]
fn bindgen_test_layout_ndpi_llc_header_snap() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_llc_header_snap> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_llc_header_snap>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_llc_header_snap))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_llc_header_snap>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_llc_header_snap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_llc_header_snap),
            "::",
            stringify!(dsap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssap) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_llc_header_snap),
            "::",
            stringify!(ssap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_llc_header_snap),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snap) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_llc_header_snap),
            "::",
            stringify!(snap)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_radiotap_header {
    pub version: u_int8_t,
    pub pad: u_int8_t,
    pub len: u_int16_t,
    pub present: u_int32_t,
    pub MAC_timestamp: u_int64_t,
    pub flags: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_radiotap_header() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_radiotap_header> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_radiotap_header>(),
        17usize,
        concat!("Size of: ", stringify!(ndpi_radiotap_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_radiotap_header>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_radiotap_header))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_radiotap_header),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_radiotap_header),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_radiotap_header),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).present) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_radiotap_header),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MAC_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_radiotap_header),
            "::",
            stringify!(MAC_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_radiotap_header),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_wifi_header {
    pub fc: u_int16_t,
    pub duration: u_int16_t,
    pub rcvr: [u_char; 6usize],
    pub trsm: [u_char; 6usize],
    pub dest: [u_char; 6usize],
    pub seq_ctrl: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_wifi_header() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_wifi_header> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_wifi_header>(),
        24usize,
        concat!("Size of: ", stringify!(ndpi_wifi_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_wifi_header>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_wifi_header))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_wifi_header),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_wifi_header),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcvr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_wifi_header),
            "::",
            stringify!(rcvr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trsm) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_wifi_header),
            "::",
            stringify!(trsm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_wifi_header),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seq_ctrl) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_wifi_header),
            "::",
            stringify!(seq_ctrl)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_mpls_header {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ndpi_mpls_header() {
    assert_eq!(
        ::core::mem::size_of::<ndpi_mpls_header>(),
        4usize,
        concat!("Size of: ", stringify!(ndpi_mpls_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_mpls_header>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_mpls_header))
    );
}
impl ndpi_mpls_header {
    #[inline]
    pub fn ttl(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exp(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_exp(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn label(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_label(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ttl: u_int32_t,
        s: u_int32_t,
        exp: u_int32_t,
        label: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ttl: u32 = unsafe { ::core::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let s: u32 = unsafe { ::core::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let exp: u32 = unsafe { ::core::mem::transmute(exp) };
            exp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let label: u32 = unsafe { ::core::mem::transmute(label) };
            label as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: u_int8_t,
    pub tot_len: u_int16_t,
    pub id: u_int16_t,
    pub frag_off: u_int16_t,
    pub ttl: u_int8_t,
    pub protocol: u_int8_t,
    pub check: u_int16_t,
    pub saddr: u_int32_t,
    pub daddr: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_iphdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_iphdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_iphdr>(),
        20usize,
        concat!("Size of: ", stringify!(ndpi_iphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_iphdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_iphdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tos) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tot_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frag_off) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(frag_off)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ttl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).saddr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).daddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_iphdr),
            "::",
            stringify!(daddr)
        )
    );
}
impl ndpi_iphdr {
    #[inline]
    pub fn ihl(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: u_int8_t, version: u_int8_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_in6_addr {
    pub u6_addr: ndpi_in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_in6_addr__bindgen_ty_1 {
    pub u6_addr8: [u_int8_t; 16usize],
    pub u6_addr16: [u_int16_t; 8usize],
    pub u6_addr32: [u_int32_t; 4usize],
    pub u6_addr64: [u_int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_ndpi_in6_addr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_in6_addr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_in6_addr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u6_addr64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_in6_addr__bindgen_ty_1),
            "::",
            stringify!(u6_addr64)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_in6_addr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_in6_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_in6_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_in6_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_in6_addr),
            "::",
            stringify!(u6_addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ip6_hdrctl {
    pub ip6_un1_flow: u_int32_t,
    pub ip6_un1_plen: u_int16_t,
    pub ip6_un1_nxt: u_int8_t,
    pub ip6_un1_hlim: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_ip6_hdrctl() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ip6_hdrctl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ip6_hdrctl>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_ip6_hdrctl))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ip6_hdrctl>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_ip6_hdrctl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_un1_flow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ip6_hdrctl),
            "::",
            stringify!(ip6_un1_flow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_un1_plen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ip6_hdrctl),
            "::",
            stringify!(ip6_un1_plen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_un1_nxt) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ip6_hdrctl),
            "::",
            stringify!(ip6_un1_nxt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_un1_hlim) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ip6_hdrctl),
            "::",
            stringify!(ip6_un1_hlim)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_ipv6hdr {
    pub ip6_hdr: ndpi_ip6_hdrctl,
    pub ip6_src: ndpi_in6_addr,
    pub ip6_dst: ndpi_in6_addr,
}
#[test]
fn bindgen_test_layout_ndpi_ipv6hdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ipv6hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ipv6hdr>(),
        40usize,
        concat!("Size of: ", stringify!(ndpi_ipv6hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ipv6hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_ipv6hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ipv6hdr),
            "::",
            stringify!(ip6_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_src) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ipv6hdr),
            "::",
            stringify!(ip6_src)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_dst) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ipv6hdr),
            "::",
            stringify!(ip6_dst)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_tcphdr {
    pub source: u_int16_t,
    pub dest: u_int16_t,
    pub seq: u_int32_t,
    pub ack_seq: u_int32_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u_int16_t,
    pub check: u_int16_t,
    pub urg_ptr: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_tcphdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_tcphdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(ndpi_tcphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_tcphdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_tcphdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ack_seq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).urg_ptr) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tcphdr),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl ndpi_tcphdr {
    #[inline]
    pub fn res1(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ece(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ece(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cwr(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cwr(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u_int16_t,
        doff: u_int16_t,
        fin: u_int16_t,
        syn: u_int16_t,
        rst: u_int16_t,
        psh: u_int16_t,
        ack: u_int16_t,
        urg: u_int16_t,
        ece: u_int16_t,
        cwr: u_int16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ece: u16 = unsafe { ::core::mem::transmute(ece) };
            ece as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cwr: u16 = unsafe { ::core::mem::transmute(cwr) };
            cwr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_udphdr {
    pub source: u_int16_t,
    pub dest: u_int16_t,
    pub len: u_int16_t,
    pub check: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_udphdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_udphdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_udphdr>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_udphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_udphdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_udphdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_udphdr),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_udphdr),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_udphdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_udphdr),
            "::",
            stringify!(check)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_dns_packet_header {
    pub tr_id: u_int16_t,
    pub flags: u_int16_t,
    pub num_queries: u_int16_t,
    pub num_answers: u_int16_t,
    pub authority_rrs: u_int16_t,
    pub additional_rrs: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_dns_packet_header() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_dns_packet_header> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_dns_packet_header>(),
        12usize,
        concat!("Size of: ", stringify!(ndpi_dns_packet_header))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_dns_packet_header>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_dns_packet_header))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tr_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dns_packet_header),
            "::",
            stringify!(tr_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dns_packet_header),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_queries) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dns_packet_header),
            "::",
            stringify!(num_queries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_answers) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dns_packet_header),
            "::",
            stringify!(num_answers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authority_rrs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dns_packet_header),
            "::",
            stringify!(authority_rrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).additional_rrs) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_dns_packet_header),
            "::",
            stringify!(additional_rrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_ip_addr_t {
    pub ipv4: u_int32_t,
    pub ipv6: ndpi_in6_addr,
}
#[test]
fn bindgen_test_layout_ndpi_ip_addr_t() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ip_addr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ip_addr_t>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_ip_addr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ip_addr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_ip_addr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ip_addr_t),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ip_addr_t),
            "::",
            stringify!(ipv6)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_icmphdr {
    pub type_: u_int8_t,
    pub code: u_int8_t,
    pub checksum: u_int16_t,
    pub un: ndpi_icmphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_icmphdr__bindgen_ty_1 {
    pub echo: ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1,
    pub gateway: u_int32_t,
    pub frag: ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1 {
    pub id: u_int16_t,
    pub sequence: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2 {
    pub _unused: u_int16_t,
    pub mtu: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_unused)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mtu)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_icmphdr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_icmphdr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_icmphdr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ndpi_icmphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_icmphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_icmphdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).echo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1),
            "::",
            stringify!(echo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gateway) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1),
            "::",
            stringify!(gateway)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr__bindgen_ty_1),
            "::",
            stringify!(frag)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_icmphdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_icmphdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_icmphdr>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_icmphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_icmphdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_icmphdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).un) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmphdr),
            "::",
            stringify!(un)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndpi_icmp6hdr {
    pub icmp6_type: u8,
    pub icmp6_code: u8,
    pub icmp6_cksum: u16,
    pub icmp6_dataun: ndpi_icmp6hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_icmp6hdr__bindgen_ty_1 {
    pub icmp6_un_data32: [u32; 1usize],
    pub icmp6_un_data16: [u16; 2usize],
    pub icmp6_un_data8: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_ndpi_icmp6hdr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_icmp6hdr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_icmp6hdr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ndpi_icmp6hdr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_icmp6hdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_icmp6hdr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_un_data32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr__bindgen_ty_1),
            "::",
            stringify!(icmp6_un_data32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_un_data16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr__bindgen_ty_1),
            "::",
            stringify!(icmp6_un_data16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_un_data8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr__bindgen_ty_1),
            "::",
            stringify!(icmp6_un_data8)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_icmp6hdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_icmp6hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_icmp6hdr>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_icmp6hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_icmp6hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_icmp6hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr),
            "::",
            stringify!(icmp6_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_code) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr),
            "::",
            stringify!(icmp6_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_cksum) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr),
            "::",
            stringify!(icmp6_cksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6_dataun) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_icmp6hdr),
            "::",
            stringify!(icmp6_dataun)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_vxlanhdr {
    pub flags: u_int16_t,
    pub groupPolicy: u_int16_t,
    pub vni: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_vxlanhdr() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_vxlanhdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_vxlanhdr>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_vxlanhdr))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_vxlanhdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_vxlanhdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_vxlanhdr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).groupPolicy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_vxlanhdr),
            "::",
            stringify!(groupPolicy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vni) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_vxlanhdr),
            "::",
            stringify!(vni)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct message {
    pub buffer: *mut u_int8_t,
    pub buffer_len: u_int,
    pub buffer_used: u_int,
    pub next_seq: [u_int32_t; 2usize],
}
#[test]
fn bindgen_test_layout_message() {
    const UNINIT: ::core::mem::MaybeUninit<message> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<message>(),
        24usize,
        concat!("Size of: ", stringify!(message))
    );
    assert_eq!(
        ::core::mem::align_of::<message>(),
        8usize,
        concat!("Alignment of ", stringify!(message))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(message),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(message),
            "::",
            stringify!(buffer_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_used) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(message),
            "::",
            stringify!(buffer_used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_seq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(message),
            "::",
            stringify!(next_seq)
        )
    );
}
pub type message_t = message;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tinc_cache_entry {
    pub src_address: u_int32_t,
    pub dst_address: u_int32_t,
    pub dst_port: u_int16_t,
}
#[test]
fn bindgen_test_layout_tinc_cache_entry() {
    const UNINIT: ::core::mem::MaybeUninit<tinc_cache_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tinc_cache_entry>(),
        10usize,
        concat!("Size of: ", stringify!(tinc_cache_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<tinc_cache_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(tinc_cache_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tinc_cache_entry),
            "::",
            stringify!(src_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tinc_cache_entry),
            "::",
            stringify!(dst_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tinc_cache_entry),
            "::",
            stringify!(dst_port)
        )
    );
}
pub const ndpi_http_method_NDPI_HTTP_METHOD_UNKNOWN: ndpi_http_method = 0;
pub const ndpi_http_method_NDPI_HTTP_METHOD_OPTIONS: ndpi_http_method = 1;
pub const ndpi_http_method_NDPI_HTTP_METHOD_GET: ndpi_http_method = 2;
pub const ndpi_http_method_NDPI_HTTP_METHOD_HEAD: ndpi_http_method = 3;
pub const ndpi_http_method_NDPI_HTTP_METHOD_PATCH: ndpi_http_method = 4;
pub const ndpi_http_method_NDPI_HTTP_METHOD_POST: ndpi_http_method = 5;
pub const ndpi_http_method_NDPI_HTTP_METHOD_PUT: ndpi_http_method = 6;
pub const ndpi_http_method_NDPI_HTTP_METHOD_DELETE: ndpi_http_method = 7;
pub const ndpi_http_method_NDPI_HTTP_METHOD_TRACE: ndpi_http_method = 8;
pub const ndpi_http_method_NDPI_HTTP_METHOD_CONNECT: ndpi_http_method = 9;
pub type ndpi_http_method = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_lru_cache_entry {
    pub key: u_int32_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ndpi_lru_cache_entry() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_lru_cache_entry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_lru_cache_entry>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_lru_cache_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_lru_cache_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_lru_cache_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_lru_cache_entry),
            "::",
            stringify!(key)
        )
    );
}
impl ndpi_lru_cache_entry {
    #[inline]
    pub fn is_full(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_full(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn value(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_value(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_full: u_int32_t,
        value: u_int32_t,
        pad: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_full: u32 = unsafe { ::core::mem::transmute(is_full) };
            is_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 16u8, {
            let value: u32 = unsafe { ::core::mem::transmute(value) };
            value as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let pad: u32 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_lru_cache {
    pub num_entries: u_int32_t,
    pub entries: *mut ndpi_lru_cache_entry,
}
#[test]
fn bindgen_test_layout_ndpi_lru_cache() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_lru_cache> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_lru_cache>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_lru_cache))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_lru_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_lru_cache))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_lru_cache),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_lru_cache),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_tcp_struct {
    pub ftp_imap_pop_smtp: ndpi_flow_tcp_struct__bindgen_ty_1,
    pub smtp_command_bitmask: u_int16_t,
    pub pop_command_bitmask: u_int16_t,
    pub wa_matched_so_far: u_int8_t,
    pub irc_stage: u_int8_t,
    pub h323_valid_packets: u_int8_t,
    pub gnutella_msg_id: [u_int8_t; 3usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tls: ndpi_flow_tcp_struct__bindgen_ty_2,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub skype_packet_id: u_int8_t,
    pub citrix_packet_id: u_int8_t,
    pub lotus_notes_packet_id: u_int8_t,
    pub teamviewer_stage: u_int8_t,
    pub prev_zmq_pkt_len: u_int8_t,
    pub prev_zmq_pkt: [u_char; 10usize],
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub memcached_matches: u_int8_t,
    pub nest_log_sink_matches: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_tcp_struct__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub username: [libc::c_char; 32usize],
    pub password: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_tcp_struct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_tcp_struct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_tcp_struct__bindgen_ty_1>(),
        49usize,
        concat!("Size of: ", stringify!(ndpi_flow_tcp_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_tcp_struct__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_1),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_1),
            "::",
            stringify!(password)
        )
    );
}
impl ndpi_flow_tcp_struct__bindgen_ty_1 {
    #[inline]
    pub fn auth_found(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_found(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auth_failed(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_failed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auth_tls(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auth_done(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auth_done(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        auth_found: u_int8_t,
        auth_failed: u_int8_t,
        auth_tls: u_int8_t,
        auth_done: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auth_found: u8 = unsafe { ::core::mem::transmute(auth_found) };
            auth_found as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auth_failed: u8 = unsafe { ::core::mem::transmute(auth_failed) };
            auth_failed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let auth_tls: u8 = unsafe { ::core::mem::transmute(auth_tls) };
            auth_tls as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let auth_done: u8 = unsafe { ::core::mem::transmute(auth_done) };
            auth_done as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _pad: u8 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_tcp_struct__bindgen_ty_2 {
    pub message: message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub num_tls_blocks: u_int8_t,
    pub tls_application_blocks_len: [i16; 8usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_tcp_struct__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_tcp_struct__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_tcp_struct__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(ndpi_flow_tcp_struct__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_tcp_struct__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_2),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_tls_blocks) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_2),
            "::",
            stringify!(num_tls_blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_application_blocks_len) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct__bindgen_ty_2),
            "::",
            stringify!(tls_application_blocks_len)
        )
    );
}
impl ndpi_flow_tcp_struct__bindgen_ty_2 {
    #[inline]
    pub fn certificate_processed(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_certificate_processed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fingerprint_set(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fingerprint_set(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        certificate_processed: u_int8_t,
        fingerprint_set: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let certificate_processed: u8 =
                unsafe { ::core::mem::transmute(certificate_processed) };
            certificate_processed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fingerprint_set: u8 = unsafe { ::core::mem::transmute(fingerprint_set) };
            fingerprint_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let _pad: u8 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ndpi_flow_tcp_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_tcp_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_tcp_struct>(),
        136usize,
        concat!("Size of: ", stringify!(ndpi_flow_tcp_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_tcp_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_tcp_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftp_imap_pop_smtp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(ftp_imap_pop_smtp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smtp_command_bitmask) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(smtp_command_bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pop_command_bitmask) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(pop_command_bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wa_matched_so_far) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(wa_matched_so_far)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).irc_stage) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(irc_stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h323_valid_packets) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(h323_valid_packets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnutella_msg_id) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(gnutella_msg_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(tls)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skype_packet_id) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(skype_packet_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).citrix_packet_id) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(citrix_packet_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lotus_notes_packet_id) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(lotus_notes_packet_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).teamviewer_stage) as usize - ptr as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(teamviewer_stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_zmq_pkt_len) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(prev_zmq_pkt_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_zmq_pkt) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(prev_zmq_pkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memcached_matches) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(memcached_matches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nest_log_sink_matches) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_tcp_struct),
            "::",
            stringify!(nest_log_sink_matches)
        )
    );
}
impl ndpi_flow_tcp_struct {
    #[inline]
    pub fn irc_3a_counter(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_irc_3a_counter(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn irc_stage2(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_irc_stage2(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn irc_direction(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_irc_direction(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn irc_0x1000_full(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irc_0x1000_full(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usenet_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_usenet_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn http_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_http_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn http_empty_line_seen(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http_empty_line_seen(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gnutella_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gnutella_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ssh_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ssh_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn vnc_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vnc_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn telnet_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_telnet_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        irc_3a_counter: u_int32_t,
        irc_stage2: u_int32_t,
        irc_direction: u_int32_t,
        irc_0x1000_full: u_int32_t,
        usenet_stage: u_int32_t,
        http_stage: u_int32_t,
        http_empty_line_seen: u_int32_t,
        gnutella_stage: u_int32_t,
        ssh_stage: u_int32_t,
        vnc_stage: u_int32_t,
        telnet_stage: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let irc_3a_counter: u32 = unsafe { ::core::mem::transmute(irc_3a_counter) };
            irc_3a_counter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let irc_stage2: u32 = unsafe { ::core::mem::transmute(irc_stage2) };
            irc_stage2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let irc_direction: u32 = unsafe { ::core::mem::transmute(irc_direction) };
            irc_direction as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irc_0x1000_full: u32 = unsafe { ::core::mem::transmute(irc_0x1000_full) };
            irc_0x1000_full as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let usenet_stage: u32 = unsafe { ::core::mem::transmute(usenet_stage) };
            usenet_stage as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let http_stage: u32 = unsafe { ::core::mem::transmute(http_stage) };
            http_stage as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let http_empty_line_seen: u32 = unsafe { ::core::mem::transmute(http_empty_line_seen) };
            http_empty_line_seen as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let gnutella_stage: u32 = unsafe { ::core::mem::transmute(gnutella_stage) };
            gnutella_stage as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let ssh_stage: u32 = unsafe { ::core::mem::transmute(ssh_stage) };
            ssh_stage as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let vnc_stage: u32 = unsafe { ::core::mem::transmute(vnc_stage) };
            vnc_stage as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let telnet_stage: u32 = unsafe { ::core::mem::transmute(telnet_stage) };
            telnet_stage as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn postgres_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_postgres_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn seen_syn(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seen_syn(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seen_syn_ack(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seen_syn_ack(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seen_ack(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seen_ack(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icecast_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icecast_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dofus_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dofus_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fiesta_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fiesta_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn wow_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_wow_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn shoutcast_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shoutcast_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtp_special_packets_seen(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtp_special_packets_seen(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mail_pop_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mail_pop_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mail_imap_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mail_imap_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mail_imap_starttls(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mail_imap_starttls(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn soap_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_soap_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        postgres_stage: u_int32_t,
        seen_syn: u_int32_t,
        seen_syn_ack: u_int32_t,
        seen_ack: u_int32_t,
        icecast_stage: u_int32_t,
        dofus_stage: u_int32_t,
        fiesta_stage: u_int32_t,
        wow_stage: u_int32_t,
        shoutcast_stage: u_int32_t,
        rtp_special_packets_seen: u_int32_t,
        mail_pop_stage: u_int32_t,
        mail_imap_stage: u_int32_t,
        mail_imap_starttls: u_int32_t,
        soap_stage: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let postgres_stage: u32 = unsafe { ::core::mem::transmute(postgres_stage) };
            postgres_stage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let seen_syn: u32 = unsafe { ::core::mem::transmute(seen_syn) };
            seen_syn as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let seen_syn_ack: u32 = unsafe { ::core::mem::transmute(seen_syn_ack) };
            seen_syn_ack as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let seen_ack: u32 = unsafe { ::core::mem::transmute(seen_ack) };
            seen_ack as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let icecast_stage: u32 = unsafe { ::core::mem::transmute(icecast_stage) };
            icecast_stage as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dofus_stage: u32 = unsafe { ::core::mem::transmute(dofus_stage) };
            dofus_stage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let fiesta_stage: u32 = unsafe { ::core::mem::transmute(fiesta_stage) };
            fiesta_stage as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let wow_stage: u32 = unsafe { ::core::mem::transmute(wow_stage) };
            wow_stage as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let shoutcast_stage: u32 = unsafe { ::core::mem::transmute(shoutcast_stage) };
            shoutcast_stage as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let rtp_special_packets_seen: u32 =
                unsafe { ::core::mem::transmute(rtp_special_packets_seen) };
            rtp_special_packets_seen as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let mail_pop_stage: u32 = unsafe { ::core::mem::transmute(mail_pop_stage) };
            mail_pop_stage as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let mail_imap_stage: u32 = unsafe { ::core::mem::transmute(mail_imap_stage) };
            mail_imap_stage as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let mail_imap_starttls: u32 = unsafe { ::core::mem::transmute(mail_imap_starttls) };
            mail_imap_starttls as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let soap_stage: u32 = unsafe { ::core::mem::transmute(soap_stage) };
            soap_stage as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn ppstream_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppstream_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(ppstream_stage: u_int32_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ppstream_stage: u32 = unsafe { ::core::mem::transmute(ppstream_stage) };
            ppstream_stage as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_udp_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub skype_packet_id: u_int8_t,
    pub skype_crc: [u_int8_t; 4usize],
    pub teamviewer_stage: u_int8_t,
    pub eaq_pkt_id: u_int8_t,
    pub eaq_sequence: u_int32_t,
    pub rx_conn_epoch: u_int32_t,
    pub rx_conn_id: u_int32_t,
    pub memcached_matches: u_int8_t,
    pub wireguard_stage: u_int8_t,
    pub wireguard_peer_index: [u_int32_t; 2usize],
    pub quic_reasm_buf: *mut u_int8_t,
    pub quic_reasm_buf_len: u_int32_t,
    pub csgo_strid: [u_int8_t; 18usize],
    pub csgo_state: u_int8_t,
    pub csgo_s2: u_int8_t,
    pub csgo_id2: u_int32_t,
    pub rdp_to_srv: [u_int8_t; 3usize],
    pub rdp_from_srv: [u_int8_t; 3usize],
    pub rdp_to_srv_pkts: u_int8_t,
    pub rdp_from_srv_pkts: u_int8_t,
    pub imo_last_one_byte_pkt: u_int8_t,
    pub imo_last_byte: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_flow_udp_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_udp_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_udp_struct>(),
        88usize,
        concat!("Size of: ", stringify!(ndpi_flow_udp_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_udp_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_udp_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skype_packet_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(skype_packet_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skype_crc) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(skype_crc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).teamviewer_stage) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(teamviewer_stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eaq_pkt_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(eaq_pkt_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eaq_sequence) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(eaq_sequence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_conn_epoch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(rx_conn_epoch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_conn_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(rx_conn_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memcached_matches) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(memcached_matches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wireguard_stage) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(wireguard_stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wireguard_peer_index) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(wireguard_peer_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quic_reasm_buf) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(quic_reasm_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quic_reasm_buf_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(quic_reasm_buf_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).csgo_strid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(csgo_strid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).csgo_state) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(csgo_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).csgo_s2) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(csgo_s2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).csgo_id2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(csgo_id2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdp_to_srv) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(rdp_to_srv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdp_from_srv) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(rdp_from_srv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdp_to_srv_pkts) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(rdp_to_srv_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdp_from_srv_pkts) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(rdp_from_srv_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imo_last_one_byte_pkt) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(imo_last_one_byte_pkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imo_last_byte) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_udp_struct),
            "::",
            stringify!(imo_last_byte)
        )
    );
}
impl ndpi_flow_udp_struct {
    #[inline]
    pub fn ppstream_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppstream_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn halflife2_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_halflife2_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tftp_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tftp_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn aimini_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_aimini_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xbox_stage(&self) -> u_int32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xbox_stage(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ppstream_stage: u_int32_t,
        halflife2_stage: u_int32_t,
        tftp_stage: u_int32_t,
        aimini_stage: u_int32_t,
        xbox_stage: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ppstream_stage: u32 = unsafe { ::core::mem::transmute(ppstream_stage) };
            ppstream_stage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let halflife2_stage: u32 = unsafe { ::core::mem::transmute(halflife2_stage) };
            halflife2_stage as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let tftp_stage: u32 = unsafe { ::core::mem::transmute(tftp_stage) };
            tftp_stage as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let aimini_stage: u32 = unsafe { ::core::mem::transmute(aimini_stage) };
            aimini_stage as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let xbox_stage: u32 = unsafe { ::core::mem::transmute(xbox_stage) };
            xbox_stage as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_int_one_line_struct {
    pub ptr: *const u_int8_t,
    pub len: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_int_one_line_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_int_one_line_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_int_one_line_struct>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_int_one_line_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_int_one_line_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_int_one_line_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_int_one_line_struct),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_int_one_line_struct),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_packet_struct {
    pub iph: *const ndpi_iphdr,
    pub iphv6: *const ndpi_ipv6hdr,
    pub tcp: *const ndpi_tcphdr,
    pub udp: *const ndpi_udphdr,
    pub generic_l4_ptr: *const u_int8_t,
    pub payload: *const u_int8_t,
    pub current_time_ms: u_int64_t,
    pub line: [ndpi_int_one_line_struct; 64usize],
    pub host_line: ndpi_int_one_line_struct,
    pub forwarded_line: ndpi_int_one_line_struct,
    pub referer_line: ndpi_int_one_line_struct,
    pub content_line: ndpi_int_one_line_struct,
    pub content_disposition_line: ndpi_int_one_line_struct,
    pub accept_line: ndpi_int_one_line_struct,
    pub authorization_line: ndpi_int_one_line_struct,
    pub user_agent_line: ndpi_int_one_line_struct,
    pub http_url_name: ndpi_int_one_line_struct,
    pub http_encoding: ndpi_int_one_line_struct,
    pub http_transfer_encoding: ndpi_int_one_line_struct,
    pub http_contentlen: ndpi_int_one_line_struct,
    pub http_cookie: ndpi_int_one_line_struct,
    pub http_origin: ndpi_int_one_line_struct,
    pub http_x_session_type: ndpi_int_one_line_struct,
    pub server_line: ndpi_int_one_line_struct,
    pub http_method: ndpi_int_one_line_struct,
    pub http_response: ndpi_int_one_line_struct,
    pub http_num_headers: u_int8_t,
    pub l3_packet_len: u_int16_t,
    pub payload_packet_len: u_int16_t,
    pub parsed_lines: u_int16_t,
    pub empty_line_position: u_int16_t,
    pub tcp_retransmission: u_int8_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_ndpi_packet_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_packet_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_packet_struct>(),
        1384usize,
        concat!("Size of: ", stringify!(ndpi_packet_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_packet_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_packet_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(iph)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iphv6) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(iphv6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic_l4_ptr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(generic_l4_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_time_ms) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(current_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_line) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(host_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forwarded_line) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(forwarded_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).referer_line) as usize - ptr as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(referer_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).content_line) as usize - ptr as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(content_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).content_disposition_line) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(content_disposition_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accept_line) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(accept_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authorization_line) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(authorization_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_agent_line) as usize - ptr as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(user_agent_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_url_name) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_url_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_encoding) as usize - ptr as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_encoding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_transfer_encoding) as usize - ptr as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_transfer_encoding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_contentlen) as usize - ptr as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_contentlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_cookie) as usize - ptr as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_origin) as usize - ptr as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_x_session_type) as usize - ptr as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_x_session_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_line) as usize - ptr as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(server_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_method) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_response) as usize - ptr as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http_num_headers) as usize - ptr as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(http_num_headers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l3_packet_len) as usize - ptr as usize },
        1370usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(l3_packet_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload_packet_len) as usize - ptr as usize },
        1372usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(payload_packet_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parsed_lines) as usize - ptr as usize },
        1374usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(parsed_lines)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).empty_line_position) as usize - ptr as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(empty_line_position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcp_retransmission) as usize - ptr as usize },
        1378usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_packet_struct),
            "::",
            stringify!(tcp_retransmission)
        )
    );
}
impl ndpi_packet_struct {
    #[inline]
    pub fn packet_lines_parsed_complete(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_packet_lines_parsed_complete(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn packet_direction(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_packet_direction(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn empty_line_position_set(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_empty_line_position_set(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http_check_content(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_http_check_content(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        packet_lines_parsed_complete: u_int8_t,
        packet_direction: u_int8_t,
        empty_line_position_set: u_int8_t,
        http_check_content: u_int8_t,
        pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let packet_lines_parsed_complete: u8 =
                unsafe { ::core::mem::transmute(packet_lines_parsed_complete) };
            packet_lines_parsed_complete as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let packet_direction: u8 = unsafe { ::core::mem::transmute(packet_direction) };
            packet_direction as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let empty_line_position_set: u8 =
                unsafe { ::core::mem::transmute(empty_line_position_set) };
            empty_line_position_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let http_check_content: u8 = unsafe { ::core::mem::transmute(http_check_content) };
            http_check_content as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let pad: u8 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_detection_module_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_call_function_struct {
    pub detection_bitmask: ndpi_protocol_bitmask_struct_t,
    pub excluded_protocol_bitmask: ndpi_protocol_bitmask_struct_t,
    pub func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ndpi_detection_module_struct, flow: *mut ndpi_flow_struct),
    >,
    pub ndpi_selection_bitmask: u_int32_t,
    pub ndpi_protocol_id: u_int16_t,
    pub detection_feature: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_call_function_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_call_function_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_call_function_struct>(),
        144usize,
        concat!("Size of: ", stringify!(ndpi_call_function_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_call_function_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_call_function_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detection_bitmask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_call_function_struct),
            "::",
            stringify!(detection_bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).excluded_protocol_bitmask) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_call_function_struct),
            "::",
            stringify!(excluded_protocol_bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_call_function_struct),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ndpi_selection_bitmask) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_call_function_struct),
            "::",
            stringify!(ndpi_selection_bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ndpi_protocol_id) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_call_function_struct),
            "::",
            stringify!(ndpi_protocol_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detection_feature) as usize - ptr as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_call_function_struct),
            "::",
            stringify!(detection_feature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_subprotocol_conf_struct {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndpi_detection_module_struct,
            attr: *mut libc::c_char,
            value: *mut libc::c_char,
            protocol_id: libc::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ndpi_subprotocol_conf_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_subprotocol_conf_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_subprotocol_conf_struct>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_subprotocol_conf_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_subprotocol_conf_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_subprotocol_conf_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_subprotocol_conf_struct),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_port_range {
    pub port_low: u_int16_t,
    pub port_high: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_port_range() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_port_range> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_port_range>(),
        4usize,
        concat!("Size of: ", stringify!(ndpi_port_range))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_port_range>(),
        2usize,
        concat!("Alignment of ", stringify!(ndpi_port_range))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_port_range),
            "::",
            stringify!(port_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_high) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_port_range),
            "::",
            stringify!(port_high)
        )
    );
}
pub const ndpi_confidence_t_NDPI_CONFIDENCE_UNKNOWN: ndpi_confidence_t = 0;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_MATCH_BY_PORT: ndpi_confidence_t = 1;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_MATCH_BY_IP: ndpi_confidence_t = 2;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI_CACHE: ndpi_confidence_t = 3;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_DPI: ndpi_confidence_t = 4;
pub const ndpi_confidence_t_NDPI_CONFIDENCE_MAX: ndpi_confidence_t = 5;
pub type ndpi_confidence_t = libc::c_uint;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_SAFE: ndpi_protocol_breed_t = 0;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_ACCEPTABLE: ndpi_protocol_breed_t = 1;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_FUN: ndpi_protocol_breed_t = 2;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_UNSAFE: ndpi_protocol_breed_t = 3;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_POTENTIALLY_DANGEROUS: ndpi_protocol_breed_t = 4;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_DANGEROUS: ndpi_protocol_breed_t = 5;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_TRACKER_ADS: ndpi_protocol_breed_t = 6;
pub const ndpi_protocol_breed_t_NDPI_PROTOCOL_UNRATED: ndpi_protocol_breed_t = 7;
pub type ndpi_protocol_breed_t = libc::c_uint;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_UNSPECIFIED: ndpi_protocol_category_t = 0;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MEDIA: ndpi_protocol_category_t = 1;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VPN: ndpi_protocol_category_t = 2;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MAIL: ndpi_protocol_category_t = 3;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER: ndpi_protocol_category_t =
    4;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_WEB: ndpi_protocol_category_t = 5;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK: ndpi_protocol_category_t =
    6;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT: ndpi_protocol_category_t = 7;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_GAME: ndpi_protocol_category_t = 8;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CHAT: ndpi_protocol_category_t = 9;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VOIP: ndpi_protocol_category_t = 10;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_DATABASE: ndpi_protocol_category_t = 11;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS: ndpi_protocol_category_t =
    12;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CLOUD: ndpi_protocol_category_t = 13;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_NETWORK: ndpi_protocol_category_t = 14;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_COLLABORATIVE: ndpi_protocol_category_t =
    15;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_RPC: ndpi_protocol_category_t = 16;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_STREAMING: ndpi_protocol_category_t = 17;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SYSTEM_OS: ndpi_protocol_category_t = 18;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SW_UPDATE: ndpi_protocol_category_t = 19;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_1: ndpi_protocol_category_t = 20;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_2: ndpi_protocol_category_t = 21;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_3: ndpi_protocol_category_t = 22;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_4: ndpi_protocol_category_t = 23;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CUSTOM_5: ndpi_protocol_category_t = 24;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_MUSIC: ndpi_protocol_category_t = 25;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VIDEO: ndpi_protocol_category_t = 26;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_SHOPPING: ndpi_protocol_category_t = 27;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_PRODUCTIVITY: ndpi_protocol_category_t =
    28;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_FILE_SHARING: ndpi_protocol_category_t =
    29;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_CONNECTIVITY_CHECK:
    ndpi_protocol_category_t = 30;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_IOT_SCADA: ndpi_protocol_category_t = 31;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_CATEGORY_VIRTUAL_ASSISTANT:
    ndpi_protocol_category_t = 32;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_MINING: ndpi_protocol_category_t = 99;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_MALWARE: ndpi_protocol_category_t = 100;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_ADVERTISEMENT: ndpi_protocol_category_t = 101;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_BANNED_SITE: ndpi_protocol_category_t = 102;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_SITE_UNAVAILABLE: ndpi_protocol_category_t = 103;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_ALLOWED_SITE: ndpi_protocol_category_t = 104;
pub const ndpi_protocol_category_t_CUSTOM_CATEGORY_ANTIMALWARE: ndpi_protocol_category_t = 105;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_NUM_CATEGORIES: ndpi_protocol_category_t = 106;
pub const ndpi_protocol_category_t_NDPI_PROTOCOL_ANY_CATEGORY: ndpi_protocol_category_t = 107;
pub type ndpi_protocol_category_t = libc::c_uint;
pub const ndpi_detection_preference_ndpi_pref_direction_detect_disable: ndpi_detection_preference =
    0;
pub const ndpi_detection_preference_ndpi_pref_enable_tls_block_dissection:
    ndpi_detection_preference = 1;
pub type ndpi_detection_preference = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_proto_defaults {
    pub protoName: *mut libc::c_char,
    pub protoCategory: ndpi_protocol_category_t,
    pub isClearTextProto: u_int8_t,
    pub subprotocols: *mut u_int16_t,
    pub subprotocol_count: u_int32_t,
    pub protoId: u_int16_t,
    pub protoIdx: u_int16_t,
    pub tcp_default_ports: [u_int16_t; 5usize],
    pub udp_default_ports: [u_int16_t; 5usize],
    pub protoBreed: ndpi_protocol_breed_t,
    pub func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ndpi_detection_module_struct, flow: *mut ndpi_flow_struct),
    >,
}
#[test]
fn bindgen_test_layout_ndpi_proto_defaults() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_proto_defaults> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_proto_defaults>(),
        64usize,
        concat!("Size of: ", stringify!(ndpi_proto_defaults))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_proto_defaults>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_proto_defaults))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protoName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(protoName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protoCategory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(protoCategory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).isClearTextProto) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(isClearTextProto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subprotocols) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(subprotocols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subprotocol_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(subprotocol_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protoId) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(protoId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protoIdx) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(protoIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcp_default_ports) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(tcp_default_ports)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udp_default_ports) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(udp_default_ports)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protoBreed) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(protoBreed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto_defaults),
            "::",
            stringify!(func)
        )
    );
}
pub type ndpi_proto_defaults_t = ndpi_proto_defaults;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_default_ports_tree_node {
    pub proto: *mut ndpi_proto_defaults_t,
    pub customUserProto: u_int8_t,
    pub default_port: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_default_ports_tree_node() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_default_ports_tree_node> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_default_ports_tree_node>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_default_ports_tree_node))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_default_ports_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_default_ports_tree_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proto) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_default_ports_tree_node),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).customUserProto) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_default_ports_tree_node),
            "::",
            stringify!(customUserProto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_port) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_default_ports_tree_node),
            "::",
            stringify!(default_port)
        )
    );
}
pub type ndpi_default_ports_tree_node_t = ndpi_default_ports_tree_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ndpi_automa {
    pub ac_automa: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout__ndpi_automa() {
    const UNINIT: ::core::mem::MaybeUninit<_ndpi_automa> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ndpi_automa>(),
        8usize,
        concat!("Size of: ", stringify!(_ndpi_automa))
    );
    assert_eq!(
        ::core::mem::align_of::<_ndpi_automa>(),
        8usize,
        concat!("Alignment of ", stringify!(_ndpi_automa))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ac_automa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ndpi_automa),
            "::",
            stringify!(ac_automa)
        )
    );
}
pub type ndpi_automa = _ndpi_automa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_proto {
    pub master_protocol: u_int16_t,
    pub app_protocol: u_int16_t,
    pub category: ndpi_protocol_category_t,
}
#[test]
fn bindgen_test_layout_ndpi_proto() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_proto> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_proto>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_proto))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_proto>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_proto))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto),
            "::",
            stringify!(master_protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_protocol) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto),
            "::",
            stringify!(app_protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_proto),
            "::",
            stringify!(category)
        )
    );
}
pub type ndpi_protocol = ndpi_proto;
pub const ndpi_cipher_weakness_ndpi_cipher_safe: ndpi_cipher_weakness = 0;
pub const ndpi_cipher_weakness_ndpi_cipher_weak: ndpi_cipher_weakness = 1;
pub const ndpi_cipher_weakness_ndpi_cipher_insecure: ndpi_cipher_weakness = 2;
pub type ndpi_cipher_weakness = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_heuristics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_tls_heuristics() {
    assert_eq!(
        ::core::mem::size_of::<tls_heuristics>(),
        1usize,
        concat!("Size of: ", stringify!(tls_heuristics))
    );
    assert_eq!(
        ::core::mem::align_of::<tls_heuristics>(),
        1usize,
        concat!("Alignment of ", stringify!(tls_heuristics))
    );
}
impl tls_heuristics {
    #[inline]
    pub fn is_safari_tls(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_safari_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_firefox_tls(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_firefox_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_chrome_tls(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_chrome_tls(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn notused(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_safari_tls: u_int8_t,
        is_firefox_tls: u_int8_t,
        is_chrome_tls: u_int8_t,
        notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_safari_tls: u8 = unsafe { ::core::mem::transmute(is_safari_tls) };
            is_safari_tls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_firefox_tls: u8 = unsafe { ::core::mem::transmute(is_firefox_tls) };
            is_firefox_tls as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_chrome_tls: u8 = unsafe { ::core::mem::transmute(is_chrome_tls) };
            is_chrome_tls as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let notused: u8 = unsafe { ::core::mem::transmute(notused) };
            notused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct {
    pub detected_protocol_stack: [u_int16_t; 2usize],
    pub guessed_protocol_id: u_int16_t,
    pub guessed_host_protocol_id: u_int16_t,
    pub guessed_category: u_int16_t,
    pub guessed_header_category: u_int16_t,
    pub l4_proto: u_int8_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub confidence: ndpi_confidence_t,
    pub next_tcp_seq_nr: [u_int32_t; 2usize],
    pub saddr: u_int32_t,
    pub daddr: u_int32_t,
    pub sport: u_int16_t,
    pub dport: u_int16_t,
    pub max_extra_packets_to_check: u_int8_t,
    pub num_extra_packets_checked: u_int8_t,
    pub num_processed_pkts: u_int16_t,
    pub extra_packets_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndpi_detection_module_struct,
            flow: *mut ndpi_flow_struct,
        ) -> libc::c_int,
    >,
    pub last_packet_time_ms: u_int64_t,
    pub l4: ndpi_flow_struct__bindgen_ty_1,
    pub entropy: f32,
    pub flow_extra_info: [libc::c_char; 16usize],
    pub host_server_name: [libc::c_char; 80usize],
    pub initial_binary_bytes: [u_int8_t; 8usize],
    pub initial_binary_bytes_len: u_int8_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub risk_mask: ndpi_risk,
    pub risk: ndpi_risk,
    pub http: ndpi_flow_struct__bindgen_ty_2,
    pub kerberos_buf: ndpi_flow_struct__bindgen_ty_3,
    pub stun: ndpi_flow_struct__bindgen_ty_4,
    pub protos: ndpi_flow_struct__bindgen_ty_5,
    #[doc = " ALL protocol specific 64 bit variables here"]
    pub excluded_protocol_bitmask: ndpi_protocol_bitmask_struct_t,
    pub category: ndpi_protocol_category_t,
    pub redis_s2d_first_char: u_int8_t,
    pub redis_d2s_first_char: u_int8_t,
    pub packet_counter: u_int16_t,
    pub packet_direction_counter: [u_int16_t; 2usize],
    pub byte_counter: [u_int16_t; 2usize],
    pub bittorrent_stage: u_int8_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub ovpn_session_id: [u_int8_t; 8usize],
    pub ovpn_counter: u_int8_t,
    pub tinc_state: u_int8_t,
    pub tinc_cache_entry: tinc_cache_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_flow_struct__bindgen_ty_1 {
    pub tcp: ndpi_flow_tcp_struct,
    pub udp: ndpi_flow_udp_struct,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_1>(),
        136usize,
        concat!("Size of: ", stringify!(ndpi_flow_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_1),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_1),
            "::",
            stringify!(udp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_2 {
    pub method: ndpi_http_method,
    pub request_version: u_int8_t,
    pub response_status_code: u_int16_t,
    pub url: *mut libc::c_char,
    pub content_type: *mut libc::c_char,
    pub request_content_type: *mut libc::c_char,
    pub user_agent: *mut libc::c_char,
    pub detected_os: *mut libc::c_char,
    pub nat_ip: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_2>(),
        56usize,
        concat!("Size of: ", stringify!(ndpi_flow_struct__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_struct__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(request_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).response_status_code) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(response_status_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).url) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).content_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(content_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_content_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(request_content_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_agent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(user_agent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detected_os) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(detected_os)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nat_ip) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_2),
            "::",
            stringify!(nat_ip)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_3 {
    pub pktbuf: *mut libc::c_char,
    pub pktbuf_maxlen: u_int16_t,
    pub pktbuf_currlen: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_flow_struct__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_struct__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pktbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_3),
            "::",
            stringify!(pktbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pktbuf_maxlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_3),
            "::",
            stringify!(pktbuf_maxlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pktbuf_currlen) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_3),
            "::",
            stringify!(pktbuf_currlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_4 {
    pub num_udp_pkts: u_int8_t,
    pub num_binding_requests: u_int8_t,
    pub num_processed_pkts: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(ndpi_flow_struct__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_4>(),
        2usize,
        concat!("Alignment of ", stringify!(ndpi_flow_struct__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_udp_pkts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_4),
            "::",
            stringify!(num_udp_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_binding_requests) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_4),
            "::",
            stringify!(num_binding_requests)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_processed_pkts) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_4),
            "::",
            stringify!(num_processed_pkts)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_flow_struct__bindgen_ty_5 {
    pub dns: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1,
    pub ntp: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2,
    pub kerberos: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3,
    pub tls_quic: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4,
    pub ssh: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5,
    pub telnet: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6,
    pub ubntac2: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7,
    pub bittorrent: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8,
    pub dhcp: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1 {
    pub num_queries: u_int8_t,
    pub num_answers: u_int8_t,
    pub reply_code: u_int8_t,
    pub is_query: u_int8_t,
    pub query_type: u_int16_t,
    pub query_class: u_int16_t,
    pub rsp_type: u_int16_t,
    pub rsp_addr: ndpi_ip_addr_t,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_queries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(num_queries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_answers) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(num_answers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reply_code) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(reply_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_query) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(is_query)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).query_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(query_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).query_class) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(query_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(rsp_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp_addr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(rsp_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2 {
    pub request_code: u_int8_t,
    pub version: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2),
            "::",
            stringify!(request_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_2),
            "::",
            stringify!(version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3 {
    pub hostname: [libc::c_char; 48usize],
    pub domain: [libc::c_char; 48usize],
    pub username: [libc::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_3),
            "::",
            stringify!(username)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4 {
    pub server_names: *mut libc::c_char,
    pub alpn: *mut libc::c_char,
    pub tls_supported_versions: *mut libc::c_char,
    pub issuerDN: *mut libc::c_char,
    pub subjectDN: *mut libc::c_char,
    pub notBefore: u_int32_t,
    pub notAfter: u_int32_t,
    pub ja3_client: [libc::c_char; 33usize],
    pub ja3_server: [libc::c_char; 33usize],
    pub server_cipher: u_int16_t,
    pub sha1_certificate_fingerprint: [u_int8_t; 20usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub browser_heuristics: tls_heuristics,
    pub ssl_version: u_int16_t,
    pub server_names_len: u_int16_t,
    pub encrypted_sni: ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1,
    pub server_unsafe_cipher: ndpi_cipher_weakness,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1 {
    pub cipher_suite: u_int16_t,
    pub esni: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_suite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(cipher_suite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).esni) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(esni)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(server_names)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(alpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_supported_versions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(tls_supported_versions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).issuerDN) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(issuerDN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subjectDN) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(subjectDN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notBefore) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(notBefore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notAfter) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(notAfter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ja3_client) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(ja3_client)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ja3_server) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(ja3_server)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_cipher) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(server_cipher)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).sha1_certificate_fingerprint) as usize - ptr as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(sha1_certificate_fingerprint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).browser_heuristics) as usize - ptr as usize },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(browser_heuristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssl_version) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(ssl_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_names_len) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(server_names_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypted_sni) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(encrypted_sni)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_unsafe_cipher) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4),
            "::",
            stringify!(server_unsafe_cipher)
        )
    );
}
impl ndpi_flow_struct__bindgen_ty_5__bindgen_ty_4 {
    #[inline]
    pub fn hello_processed(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hello_processed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subprotocol_detected(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_subprotocol_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hello_processed: u_int8_t,
        subprotocol_detected: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hello_processed: u8 = unsafe { ::core::mem::transmute(hello_processed) };
            hello_processed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let subprotocol_detected: u8 = unsafe { ::core::mem::transmute(subprotocol_detected) };
            subprotocol_detected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let _pad: u8 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5 {
    pub client_signature: [libc::c_char; 48usize],
    pub server_signature: [libc::c_char; 48usize],
    pub hassh_client: [libc::c_char; 33usize],
    pub hassh_server: [libc::c_char; 33usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5>(),
        162usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5),
            "::",
            stringify!(client_signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server_signature) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5),
            "::",
            stringify!(server_signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hassh_client) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5),
            "::",
            stringify!(hassh_client)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hassh_server) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_5),
            "::",
            stringify!(hassh_server)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub character_id: u_int8_t,
    pub username: [libc::c_char; 32usize],
    pub password: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6>(),
        66usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).character_id) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6),
            "::",
            stringify!(character_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6),
            "::",
            stringify!(password)
        )
    );
}
impl ndpi_flow_struct__bindgen_ty_5__bindgen_ty_6 {
    #[inline]
    pub fn username_detected(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_username_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn username_found(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_username_found(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn password_detected(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_password_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn password_found(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_password_found(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _pad(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__pad(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        username_detected: u_int8_t,
        username_found: u_int8_t,
        password_detected: u_int8_t,
        password_found: u_int8_t,
        _pad: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let username_detected: u8 = unsafe { ::core::mem::transmute(username_detected) };
            username_detected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let username_found: u8 = unsafe { ::core::mem::transmute(username_found) };
            username_found as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let password_detected: u8 = unsafe { ::core::mem::transmute(password_detected) };
            password_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let password_found: u8 = unsafe { ::core::mem::transmute(password_found) };
            password_found as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _pad: u8 = unsafe { ::core::mem::transmute(_pad) };
            _pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7 {
    pub version: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_7),
            "::",
            stringify!(version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8 {
    pub hash: [u_char; 20usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_8),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9 {
    pub fingerprint: [libc::c_char; 48usize],
    pub class_ident: [libc::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fingerprint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9),
            "::",
            stringify!(fingerprint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_ident) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5__bindgen_ty_9),
            "::",
            stringify!(class_ident)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct__bindgen_ty_5> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct__bindgen_ty_5>(),
        168usize,
        concat!("Size of: ", stringify!(ndpi_flow_struct__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_struct__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(dns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ntp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(ntp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kerberos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(kerberos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_quic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(tls_quic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(ssh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).telnet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(telnet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ubntac2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(ubntac2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bittorrent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(bittorrent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhcp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct__bindgen_ty_5),
            "::",
            stringify!(dhcp)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_flow_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_flow_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_flow_struct>(),
        688usize,
        concat!("Size of: ", stringify!(ndpi_flow_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_flow_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_flow_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detected_protocol_stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(detected_protocol_stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guessed_protocol_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(guessed_protocol_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guessed_host_protocol_id) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(guessed_host_protocol_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guessed_category) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(guessed_category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guessed_header_category) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(guessed_header_category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l4_proto) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(l4_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_tcp_seq_nr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(next_tcp_seq_nr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).saddr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).daddr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(daddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sport) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(sport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dport) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_extra_packets_to_check) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(max_extra_packets_to_check)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_extra_packets_checked) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(num_extra_packets_checked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_processed_pkts) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(num_processed_pkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra_packets_func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(extra_packets_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_packet_time_ms) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(last_packet_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(l4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entropy) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(entropy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flow_extra_info) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(flow_extra_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_server_name) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(host_server_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initial_binary_bytes) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(initial_binary_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initial_binary_bytes_len) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(initial_binary_bytes_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).risk_mask) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(risk_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).risk) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(risk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).http) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(http)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kerberos_buf) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(kerberos_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stun) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(stun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protos) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(protos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).excluded_protocol_bitmask) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(excluded_protocol_bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).redis_s2d_first_char) as usize - ptr as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(redis_s2d_first_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).redis_d2s_first_char) as usize - ptr as usize },
        645usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(redis_d2s_first_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_counter) as usize - ptr as usize },
        646usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(packet_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_direction_counter) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(packet_direction_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte_counter) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(byte_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bittorrent_stage) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(bittorrent_stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ovpn_session_id) as usize - ptr as usize },
        662usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(ovpn_session_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ovpn_counter) as usize - ptr as usize },
        670usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(ovpn_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tinc_state) as usize - ptr as usize },
        671usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(tinc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tinc_cache_entry) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_flow_struct),
            "::",
            stringify!(tinc_cache_entry)
        )
    );
}
impl ndpi_flow_struct {
    #[inline]
    pub fn protocol_id_already_guessed(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_protocol_id_already_guessed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_already_guessed(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_host_already_guessed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fail_with_unknown(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fail_with_unknown(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn init_finished(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_init_finished(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn setup_packet_direction(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_setup_packet_direction(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn packet_direction(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_packet_direction(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn check_extra_packets(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_check_extra_packets(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_ipv6(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_ipv6(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        protocol_id_already_guessed: u_int8_t,
        host_already_guessed: u_int8_t,
        fail_with_unknown: u_int8_t,
        init_finished: u_int8_t,
        setup_packet_direction: u_int8_t,
        packet_direction: u_int8_t,
        check_extra_packets: u_int8_t,
        is_ipv6: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let protocol_id_already_guessed: u8 =
                unsafe { ::core::mem::transmute(protocol_id_already_guessed) };
            protocol_id_already_guessed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let host_already_guessed: u8 = unsafe { ::core::mem::transmute(host_already_guessed) };
            host_already_guessed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fail_with_unknown: u8 = unsafe { ::core::mem::transmute(fail_with_unknown) };
            fail_with_unknown as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let init_finished: u8 = unsafe { ::core::mem::transmute(init_finished) };
            init_finished as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let setup_packet_direction: u8 =
                unsafe { ::core::mem::transmute(setup_packet_direction) };
            setup_packet_direction as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let packet_direction: u8 = unsafe { ::core::mem::transmute(packet_direction) };
            packet_direction as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let check_extra_packets: u8 = unsafe { ::core::mem::transmute(check_extra_packets) };
            check_extra_packets as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_ipv6: u8 = unsafe { ::core::mem::transmute(is_ipv6) };
            is_ipv6 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn risk_checked(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_risk_checked(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_risk_mask_evaluated(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ip_risk_mask_evaluated(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_risk_mask_evaluated(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_host_risk_mask_evaluated(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        risk_checked: u_int8_t,
        ip_risk_mask_evaluated: u_int8_t,
        host_risk_mask_evaluated: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let risk_checked: u8 = unsafe { ::core::mem::transmute(risk_checked) };
            risk_checked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ip_risk_mask_evaluated: u8 =
                unsafe { ::core::mem::transmute(ip_risk_mask_evaluated) };
            ip_risk_mask_evaluated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let host_risk_mask_evaluated: u8 =
                unsafe { ::core::mem::transmute(host_risk_mask_evaluated) };
            host_risk_mask_evaluated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let _notused: u8 = unsafe { ::core::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn bt_check_performed(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bt_check_performed(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directconnect_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_directconnect_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn http_detected(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_http_detected(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtsprdt_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rtsprdt_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn zattoo_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_zattoo_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn thunder_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_thunder_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn florensia_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_florensia_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn socks5_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(14usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_socks5_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn socks4_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_socks4_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn edonkey_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_edonkey_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ftp_control_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(20usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ftp_control_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rtmp_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(22usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rtmp_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn steam_stage(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(24usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_steam_stage(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_3.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn steam_stage1(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(27usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_steam_stage1(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_3.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn steam_stage2(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(30usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_steam_stage2(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_3.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn steam_stage3(&self) -> u_int16_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(32usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_steam_stage3(&mut self, val: u_int16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_3.set(32usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn starcraft_udp_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(34usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_starcraft_udp_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(34usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn z3950_stage(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(37usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_z3950_stage(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(37usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        bt_check_performed: u_int8_t,
        directconnect_stage: u_int8_t,
        http_detected: u_int8_t,
        rtsprdt_stage: u_int8_t,
        zattoo_stage: u_int8_t,
        thunder_stage: u_int8_t,
        florensia_stage: u_int8_t,
        socks5_stage: u_int8_t,
        socks4_stage: u_int8_t,
        edonkey_stage: u_int8_t,
        ftp_control_stage: u_int8_t,
        rtmp_stage: u_int8_t,
        steam_stage: u_int16_t,
        steam_stage1: u_int16_t,
        steam_stage2: u_int16_t,
        steam_stage3: u_int16_t,
        starcraft_udp_stage: u_int8_t,
        z3950_stage: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bt_check_performed: u8 = unsafe { ::core::mem::transmute(bt_check_performed) };
            bt_check_performed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let directconnect_stage: u8 = unsafe { ::core::mem::transmute(directconnect_stage) };
            directconnect_stage as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let http_detected: u8 = unsafe { ::core::mem::transmute(http_detected) };
            http_detected as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let rtsprdt_stage: u8 = unsafe { ::core::mem::transmute(rtsprdt_stage) };
            rtsprdt_stage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let zattoo_stage: u8 = unsafe { ::core::mem::transmute(zattoo_stage) };
            zattoo_stage as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let thunder_stage: u8 = unsafe { ::core::mem::transmute(thunder_stage) };
            thunder_stage as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let florensia_stage: u8 = unsafe { ::core::mem::transmute(florensia_stage) };
            florensia_stage as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let socks5_stage: u8 = unsafe { ::core::mem::transmute(socks5_stage) };
            socks5_stage as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let socks4_stage: u8 = unsafe { ::core::mem::transmute(socks4_stage) };
            socks4_stage as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let edonkey_stage: u8 = unsafe { ::core::mem::transmute(edonkey_stage) };
            edonkey_stage as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let ftp_control_stage: u8 = unsafe { ::core::mem::transmute(ftp_control_stage) };
            ftp_control_stage as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let rtmp_stage: u8 = unsafe { ::core::mem::transmute(rtmp_stage) };
            rtmp_stage as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let steam_stage: u16 = unsafe { ::core::mem::transmute(steam_stage) };
            steam_stage as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let steam_stage1: u16 = unsafe { ::core::mem::transmute(steam_stage1) };
            steam_stage1 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let steam_stage2: u16 = unsafe { ::core::mem::transmute(steam_stage2) };
            steam_stage2 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 2u8, {
            let steam_stage3: u16 = unsafe { ::core::mem::transmute(steam_stage3) };
            steam_stage3 as u64
        });
        __bindgen_bitfield_unit.set(34usize, 3u8, {
            let starcraft_udp_stage: u8 = unsafe { ::core::mem::transmute(starcraft_udp_stage) };
            starcraft_udp_stage as u64
        });
        __bindgen_bitfield_unit.set(37usize, 2u8, {
            let z3950_stage: u8 = unsafe { ::core::mem::transmute(z3950_stage) };
            z3950_stage as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_protocol_match {
    pub string_to_match: *mut libc::c_char,
    pub proto_name: *mut libc::c_char,
    pub protocol_id: u_int16_t,
    pub protocol_category: ndpi_protocol_category_t,
    pub protocol_breed: ndpi_protocol_breed_t,
    pub level: libc::c_int,
}
#[test]
fn bindgen_test_layout_ndpi_protocol_match() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_protocol_match> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_protocol_match>(),
        32usize,
        concat!("Size of: ", stringify!(ndpi_protocol_match))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_protocol_match>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_protocol_match))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string_to_match) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match),
            "::",
            stringify!(string_to_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proto_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match),
            "::",
            stringify!(proto_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match),
            "::",
            stringify!(protocol_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_category) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match),
            "::",
            stringify!(protocol_category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_breed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match),
            "::",
            stringify!(protocol_breed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match),
            "::",
            stringify!(level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_category_match {
    pub string_to_match: *mut libc::c_char,
    pub protocol_category: ndpi_protocol_category_t,
}
#[test]
fn bindgen_test_layout_ndpi_category_match() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_category_match> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_category_match>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_category_match))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_category_match>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_category_match))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string_to_match) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_category_match),
            "::",
            stringify!(string_to_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_category) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_category_match),
            "::",
            stringify!(protocol_category)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_tls_cert_name_match {
    pub string_to_match: *mut libc::c_char,
    pub protocol_id: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_tls_cert_name_match() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_tls_cert_name_match> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_tls_cert_name_match>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_tls_cert_name_match))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_tls_cert_name_match>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_tls_cert_name_match))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string_to_match) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tls_cert_name_match),
            "::",
            stringify!(string_to_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_tls_cert_name_match),
            "::",
            stringify!(protocol_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_network {
    pub network: u_int32_t,
    pub cidr: u_int8_t,
    pub value: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_network() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_network> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_network>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_network))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_network>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_network))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).network) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_network),
            "::",
            stringify!(network)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cidr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_network),
            "::",
            stringify!(cidr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_network),
            "::",
            stringify!(value)
        )
    );
}
pub type ndpi_init_prefs = u_int32_t;
pub const ndpi_prefs_ndpi_no_prefs: ndpi_prefs = 0;
pub const ndpi_prefs_ndpi_dont_load_tor_hosts: ndpi_prefs = 1;
pub const ndpi_prefs_ndpi_dont_init_libgcrypt: ndpi_prefs = 2;
pub const ndpi_prefs_ndpi_enable_ja3_plus: ndpi_prefs = 4;
pub type ndpi_prefs = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_protocol_match_result {
    pub protocol_id: u_int32_t,
    pub protocol_category: ndpi_protocol_category_t,
    pub protocol_breed: ndpi_protocol_breed_t,
}
#[test]
fn bindgen_test_layout_ndpi_protocol_match_result() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_protocol_match_result> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_protocol_match_result>(),
        12usize,
        concat!("Size of: ", stringify!(ndpi_protocol_match_result))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_protocol_match_result>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_protocol_match_result))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match_result),
            "::",
            stringify!(protocol_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_category) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match_result),
            "::",
            stringify!(protocol_category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_breed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_protocol_match_result),
            "::",
            stringify!(protocol_breed)
        )
    );
}
pub const ndpi_serialization_format_ndpi_serialization_format_unknown: ndpi_serialization_format =
    0;
pub const ndpi_serialization_format_ndpi_serialization_format_tlv: ndpi_serialization_format = 1;
pub const ndpi_serialization_format_ndpi_serialization_format_json: ndpi_serialization_format = 2;
pub const ndpi_serialization_format_ndpi_serialization_format_csv: ndpi_serialization_format = 3;
pub type ndpi_serialization_format = libc::c_uint;
pub const ndpi_serialization_type_ndpi_serialization_unknown: ndpi_serialization_type = 0;
pub const ndpi_serialization_type_ndpi_serialization_end_of_record: ndpi_serialization_type = 1;
pub const ndpi_serialization_type_ndpi_serialization_uint8: ndpi_serialization_type = 2;
pub const ndpi_serialization_type_ndpi_serialization_uint16: ndpi_serialization_type = 3;
pub const ndpi_serialization_type_ndpi_serialization_uint32: ndpi_serialization_type = 4;
pub const ndpi_serialization_type_ndpi_serialization_uint64: ndpi_serialization_type = 5;
pub const ndpi_serialization_type_ndpi_serialization_int8: ndpi_serialization_type = 6;
pub const ndpi_serialization_type_ndpi_serialization_int16: ndpi_serialization_type = 7;
pub const ndpi_serialization_type_ndpi_serialization_int32: ndpi_serialization_type = 8;
pub const ndpi_serialization_type_ndpi_serialization_int64: ndpi_serialization_type = 9;
pub const ndpi_serialization_type_ndpi_serialization_float: ndpi_serialization_type = 10;
pub const ndpi_serialization_type_ndpi_serialization_string: ndpi_serialization_type = 11;
pub const ndpi_serialization_type_ndpi_serialization_start_of_block: ndpi_serialization_type = 12;
pub const ndpi_serialization_type_ndpi_serialization_end_of_block: ndpi_serialization_type = 13;
pub const ndpi_serialization_type_ndpi_serialization_start_of_list: ndpi_serialization_type = 14;
pub const ndpi_serialization_type_ndpi_serialization_end_of_list: ndpi_serialization_type = 15;
pub type ndpi_serialization_type = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer_buffer_status {
    pub size_used: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_private_serializer_buffer_status() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_private_serializer_buffer_status> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_private_serializer_buffer_status>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ndpi_private_serializer_buffer_status)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_private_serializer_buffer_status>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_private_serializer_buffer_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_used) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_buffer_status),
            "::",
            stringify!(size_used)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer_status {
    pub flags: u_int32_t,
    pub buffer: ndpi_private_serializer_buffer_status,
    pub header: ndpi_private_serializer_buffer_status,
}
#[test]
fn bindgen_test_layout_ndpi_private_serializer_status() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_private_serializer_status> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_private_serializer_status>(),
        12usize,
        concat!("Size of: ", stringify!(ndpi_private_serializer_status))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_private_serializer_status>(),
        4usize,
        concat!("Alignment of ", stringify!(ndpi_private_serializer_status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_status),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_status),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_status),
            "::",
            stringify!(header)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer_buffer {
    pub initial_size: u_int32_t,
    pub size: u_int32_t,
    pub data: *mut u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_private_serializer_buffer() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_private_serializer_buffer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_private_serializer_buffer>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_private_serializer_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_private_serializer_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_private_serializer_buffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initial_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_buffer),
            "::",
            stringify!(initial_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_buffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer_buffer),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_private_serializer {
    pub status: ndpi_private_serializer_status,
    pub buffer: ndpi_private_serializer_buffer,
    pub header: ndpi_private_serializer_buffer,
    pub fmt: ndpi_serialization_format,
    pub csv_separator: [libc::c_char; 2usize],
    pub has_snapshot: u_int8_t,
    pub snapshot: ndpi_private_serializer_status,
}
#[test]
fn bindgen_test_layout_ndpi_private_serializer() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_private_serializer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_private_serializer>(),
        72usize,
        concat!("Size of: ", stringify!(ndpi_private_serializer))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_private_serializer>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_private_serializer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).csv_separator) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(csv_separator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_snapshot) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(has_snapshot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snapshot) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_private_serializer),
            "::",
            stringify!(snapshot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_serializer {
    pub c: [libc::c_char; 72usize],
}
#[test]
fn bindgen_test_layout_ndpi_serializer() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_serializer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_serializer>(),
        72usize,
        concat!("Size of: ", stringify!(ndpi_serializer))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_serializer>(),
        1usize,
        concat!("Alignment of ", stringify!(ndpi_serializer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_serializer),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_string {
    pub str_: *mut libc::c_char,
    pub str_len: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_string() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_string> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_string>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_string))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_string>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_string))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_string),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_string),
            "::",
            stringify!(str_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_analyze_struct {
    pub values: *mut u_int32_t,
    pub min_val: u_int32_t,
    pub max_val: u_int32_t,
    pub sum_total: u_int32_t,
    pub num_data_entries: u_int32_t,
    pub next_value_insert_index: u_int32_t,
    pub num_values_array_len: u_int16_t,
    pub stddev: ndpi_analyze_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_analyze_struct__bindgen_ty_1 {
    pub sum_square_total: u_int64_t,
}
#[test]
fn bindgen_test_layout_ndpi_analyze_struct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_analyze_struct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_analyze_struct__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_analyze_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_analyze_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ndpi_analyze_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct__bindgen_ty_1),
            "::",
            stringify!(sum_square_total)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_analyze_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_analyze_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_analyze_struct>(),
        40usize,
        concat!("Size of: ", stringify!(ndpi_analyze_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_analyze_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_analyze_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(min_val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_val) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(max_val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_total) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(sum_total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_data_entries) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(num_data_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_value_insert_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(next_value_insert_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values_array_len) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(num_values_array_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stddev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_analyze_struct),
            "::",
            stringify!(stddev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_rsi_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub num_values: u_int16_t,
    pub next_index: u_int16_t,
    pub gains: *mut u_int32_t,
    pub losses: *mut u_int32_t,
    pub last_value: u_int32_t,
    pub total_gains: u_int32_t,
    pub total_losses: u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_rsi_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_rsi_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_rsi_struct>(),
        40usize,
        concat!("Size of: ", stringify!(ndpi_rsi_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_rsi_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_rsi_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(num_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(next_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gains) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(gains)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).losses) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(losses)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(last_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_gains) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(total_gains)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_losses) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_rsi_struct),
            "::",
            stringify!(total_losses)
        )
    );
}
impl ndpi_rsi_struct {
    #[inline]
    pub fn empty(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_empty(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsi_ready(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rsi_ready(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        empty: u_int8_t,
        rsi_ready: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let empty: u8 = unsafe { ::core::mem::transmute(empty) };
            empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rsi_ready: u8 = unsafe { ::core::mem::transmute(rsi_ready) };
            rsi_ready as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let _notused: u8 = unsafe { ::core::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_jitter_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub num_values: u_int16_t,
    pub next_index: u_int16_t,
    pub observations: *mut f32,
    pub last_value: f32,
    pub jitter_total: f32,
}
#[test]
fn bindgen_test_layout_ndpi_jitter_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_jitter_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_jitter_struct>(),
        24usize,
        concat!("Size of: ", stringify!(ndpi_jitter_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_jitter_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_jitter_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_jitter_struct),
            "::",
            stringify!(num_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_jitter_struct),
            "::",
            stringify!(next_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).observations) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_jitter_struct),
            "::",
            stringify!(observations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_jitter_struct),
            "::",
            stringify!(last_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jitter_total) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_jitter_struct),
            "::",
            stringify!(jitter_total)
        )
    );
}
impl ndpi_jitter_struct {
    #[inline]
    pub fn empty(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_empty(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jitter_ready(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_jitter_ready(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _notused(&self) -> u_int8_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set__notused(&mut self, val: u_int8_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        empty: u_int8_t,
        jitter_ready: u_int8_t,
        _notused: u_int8_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let empty: u8 = unsafe { ::core::mem::transmute(empty) };
            empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jitter_ready: u8 = unsafe { ::core::mem::transmute(jitter_ready) };
            jitter_ready as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let _notused: u8 = unsafe { ::core::mem::transmute(_notused) };
            _notused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ndpi_void_fn_t = ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
pub type ndpi_void_fn2_t = ::core::option::Option<
    unsafe extern "C" fn(prefix: *mut ndpi_prefix_t, data: *mut libc::c_void),
>;
pub type ndpi_void_fn3_t = ::core::option::Option<
    unsafe extern "C" fn(
        node: *mut ndpi_patricia_node_t,
        data: *mut libc::c_void,
        user_data: *mut libc::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ptree {
    _unused: [u8; 0],
}
pub type ndpi_ptree_t = ndpi_ptree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hll {
    pub bits: u_int8_t,
    pub size: usize,
    pub registers: *mut u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_hll() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_hll> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_hll>(),
        24usize,
        concat!("Size of: ", stringify!(ndpi_hll))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_hll>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_hll))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hll),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hll),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).registers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hll),
            "::",
            stringify!(registers)
        )
    );
}
pub const ndpi_bin_family_ndpi_bin_family8: ndpi_bin_family = 0;
pub const ndpi_bin_family_ndpi_bin_family16: ndpi_bin_family = 1;
pub const ndpi_bin_family_ndpi_bin_family32: ndpi_bin_family = 2;
pub type ndpi_bin_family = libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndpi_bin {
    pub is_empty: u_int8_t,
    pub num_bins: u_int16_t,
    pub family: ndpi_bin_family,
    pub u: ndpi_bin__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ndpi_bin__bindgen_ty_1 {
    pub bins8: *mut u_int8_t,
    pub bins16: *mut u_int16_t,
    pub bins32: *mut u_int32_t,
}
#[test]
fn bindgen_test_layout_ndpi_bin__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_bin__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_bin__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ndpi_bin__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_bin__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_bin__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bins8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin__bindgen_ty_1),
            "::",
            stringify!(bins8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bins16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin__bindgen_ty_1),
            "::",
            stringify!(bins16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bins32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin__bindgen_ty_1),
            "::",
            stringify!(bins32)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_bin() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_bin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_bin>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_bin))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_bin>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_bin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_empty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin),
            "::",
            stringify!(is_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_bins) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin),
            "::",
            stringify!(num_bins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_bin),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_str_hash_info {
    pub key: *mut libc::c_char,
    pub key_len: u_int8_t,
    pub value: u_int8_t,
    pub next: *mut ndpi_str_hash_info,
}
#[test]
fn bindgen_test_layout_ndpi_str_hash_info() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_str_hash_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_str_hash_info>(),
        24usize,
        concat!("Size of: ", stringify!(ndpi_str_hash_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_str_hash_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_str_hash_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash_info),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash_info),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash_info),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash_info),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_str_hash {
    pub num_buckets: u_int32_t,
    pub max_num_entries: u_int32_t,
    pub buckets: *mut *mut ndpi_str_hash_info,
}
#[test]
fn bindgen_test_layout_ndpi_str_hash() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_str_hash> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_str_hash>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_str_hash))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_str_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_str_hash))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_buckets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash),
            "::",
            stringify!(num_buckets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_num_entries) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash),
            "::",
            stringify!(max_num_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buckets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_str_hash),
            "::",
            stringify!(buckets)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hw_struct {
    pub params: ndpi_hw_struct__bindgen_ty_1,
    pub prev_error: ndpi_hw_struct__bindgen_ty_2,
    pub num_values: u_int32_t,
    pub u: f64,
    pub v: f64,
    pub sum_square_error: f64,
    pub y: *mut u_int64_t,
    pub s: *mut f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hw_struct__bindgen_ty_1 {
    pub use_hw_additive_seasonal: u_int8_t,
    pub alpha: f64,
    pub beta: f64,
    pub gamma: f64,
    pub ro: f64,
    pub num_season_periods: u_int16_t,
}
#[test]
fn bindgen_test_layout_ndpi_hw_struct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_hw_struct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_hw_struct__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ndpi_hw_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_hw_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_hw_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_hw_additive_seasonal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_1),
            "::",
            stringify!(use_hw_additive_seasonal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_1),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_1),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_1),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ro) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_1),
            "::",
            stringify!(ro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_season_periods) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_1),
            "::",
            stringify!(num_season_periods)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_hw_struct__bindgen_ty_2 {
    pub sum_square_error: f64,
    pub num_values_rollup: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_hw_struct__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_hw_struct__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_hw_struct__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_hw_struct__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_hw_struct__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_hw_struct__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_2),
            "::",
            stringify!(sum_square_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values_rollup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct__bindgen_ty_2),
            "::",
            stringify!(num_values_rollup)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_hw_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_hw_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_hw_struct>(),
        112usize,
        concat!("Size of: ", stringify!(ndpi_hw_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_hw_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_hw_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_error) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(prev_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(num_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_error) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(sum_square_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_hw_struct),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ses_struct {
    pub params: ndpi_ses_struct__bindgen_ty_1,
    pub prev_error: ndpi_ses_struct__bindgen_ty_2,
    pub num_values: u_int32_t,
    pub sum_square_error: f64,
    pub last_forecast: f64,
    pub last_value: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ses_struct__bindgen_ty_1 {
    pub alpha: f64,
    pub ro: f64,
}
#[test]
fn bindgen_test_layout_ndpi_ses_struct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ses_struct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ses_struct__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_ses_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ses_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_ses_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct__bindgen_ty_1),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ro) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct__bindgen_ty_1),
            "::",
            stringify!(ro)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_ses_struct__bindgen_ty_2 {
    pub sum_square_error: f64,
    pub num_values_rollup: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_ses_struct__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ses_struct__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ses_struct__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_ses_struct__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ses_struct__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_ses_struct__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct__bindgen_ty_2),
            "::",
            stringify!(sum_square_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values_rollup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct__bindgen_ty_2),
            "::",
            stringify!(num_values_rollup)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_ses_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_ses_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_ses_struct>(),
        64usize,
        concat!("Size of: ", stringify!(ndpi_ses_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_ses_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_ses_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct),
            "::",
            stringify!(prev_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct),
            "::",
            stringify!(num_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_error) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct),
            "::",
            stringify!(sum_square_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_forecast) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct),
            "::",
            stringify!(last_forecast)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_ses_struct),
            "::",
            stringify!(last_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_des_struct {
    pub params: ndpi_des_struct__bindgen_ty_1,
    pub prev_error: ndpi_des_struct__bindgen_ty_2,
    pub num_values: u_int32_t,
    pub sum_square_error: f64,
    pub last_forecast: f64,
    pub last_trend: f64,
    pub last_value: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_des_struct__bindgen_ty_1 {
    pub alpha: f64,
    pub beta: f64,
    pub ro: f64,
}
#[test]
fn bindgen_test_layout_ndpi_des_struct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_des_struct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_des_struct__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ndpi_des_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_des_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_des_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct__bindgen_ty_1),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct__bindgen_ty_1),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ro) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct__bindgen_ty_1),
            "::",
            stringify!(ro)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndpi_des_struct__bindgen_ty_2 {
    pub sum_square_error: f64,
    pub num_values_rollup: u_int8_t,
}
#[test]
fn bindgen_test_layout_ndpi_des_struct__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_des_struct__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_des_struct__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(ndpi_des_struct__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_des_struct__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_des_struct__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct__bindgen_ty_2),
            "::",
            stringify!(sum_square_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values_rollup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct__bindgen_ty_2),
            "::",
            stringify!(num_values_rollup)
        )
    );
}
#[test]
fn bindgen_test_layout_ndpi_des_struct() {
    const UNINIT: ::core::mem::MaybeUninit<ndpi_des_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ndpi_des_struct>(),
        80usize,
        concat!("Size of: ", stringify!(ndpi_des_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<ndpi_des_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(ndpi_des_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_error) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(prev_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_values) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(num_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sum_square_error) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(sum_square_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_forecast) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(last_forecast)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_trend) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(last_trend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ndpi_des_struct),
            "::",
            stringify!(last_value)
        )
    );
}
pub type ndpi_custom_dga_predict_fctn = ::core::option::Option<
    unsafe extern "C" fn(domain: *const libc::c_char, domain_length: libc::c_int) -> libc::c_int,
>;
pub type ndpi_bitmap = libc::c_void;
pub type ndpi_bitmap_iterator = libc::c_void;
extern "C" {
    pub fn ndpi_build_default_ports_range(
        ports: *mut ndpi_port_range,
        portA_low: u_int16_t,
        portA_high: u_int16_t,
        portB_low: u_int16_t,
        portB_high: u_int16_t,
        portC_low: u_int16_t,
        portC_high: u_int16_t,
        portD_low: u_int16_t,
        portD_high: u_int16_t,
        portE_low: u_int16_t,
        portE_high: u_int16_t,
    ) -> *mut ndpi_port_range;
}
extern "C" {
    pub fn ndpi_build_default_ports(
        ports: *mut ndpi_port_range,
        portA: u_int16_t,
        portB: u_int16_t,
        portC: u_int16_t,
        portD: u_int16_t,
        portE: u_int16_t,
    ) -> *mut ndpi_port_range;
}
extern "C" {
    pub fn ndpi_search_tcp_or_udp_raw(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        protocol: u_int8_t,
        saddr: u_int32_t,
        daddr: u_int32_t,
        sport: u_int16_t,
        dport: u_int16_t,
    ) -> u_int;
}
extern "C" {
    pub fn ndpi_search_tcp_or_udp(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    );
}
extern "C" {
    pub fn ndpi_search_into_bittorrent_cache(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        saddr: u_int32_t,
        sport: u_int16_t,
        daddr: u_int32_t,
        dport: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_ip_port_hash_funct(ip: u_int32_t, port: u_int16_t) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_tdelete(
        arg1: *const libc::c_void,
        arg2: *mut *mut libc::c_void,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_tfind(
        arg1: *const libc::c_void,
        arg2: *mut libc::c_void,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_tsearch(
        arg1: *const libc::c_void,
        arg2: *mut *mut libc::c_void,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_twalk(
        arg1: *const libc::c_void,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: ndpi_VISIT,
                arg3: libc::c_int,
                arg4: *mut libc::c_void,
            ),
        >,
        user_data: *mut libc::c_void,
    );
}
extern "C" {
    pub fn ndpi_tdestroy(
        vrootp: *mut libc::c_void,
        freefct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    );
}
extern "C" {
    pub fn ndpi_net_match(ip_to_check: u_int32_t, net: u_int32_t, num_bits: u_int32_t) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_ips_match(
        src: u_int32_t,
        dst: u_int32_t,
        net: u_int32_t,
        num_bits: u_int32_t,
    ) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_bytestream_to_number(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_bytestream_to_number64(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int64_t;
}
extern "C" {
    pub fn ndpi_bytestream_dec_or_hex_to_number(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_bytestream_dec_or_hex_to_number64(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int64_t;
}
extern "C" {
    pub fn ndpi_bytestream_to_ipv4(
        str_: *const u_int8_t,
        max_chars_to_read: u_int16_t,
        bytes_read: *mut u_int16_t,
    ) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_set_detected_protocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        upper_detected_protocol: u_int16_t,
        lower_detected_protocol: u_int16_t,
        confidence: ndpi_confidence_t,
    );
}
extern "C" {
    pub fn ndpi_parse_packet_line_info(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    );
}
extern "C" {
    pub fn ndpi_parse_packet_line_info_any(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    );
}
extern "C" {
    pub fn ndpi_check_for_email_address(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        counter: u_int16_t,
    ) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_int_change_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        protocol_category: ndpi_protocol_category_t,
    );
}
extern "C" {
    pub fn ndpi_set_proto_subprotocols(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: libc::c_int,
        ...
    );
}
extern "C" {
    pub fn ndpi_set_proto_defaults(
        ndpi_mod: *mut ndpi_detection_module_struct,
        is_cleartext: u_int8_t,
        protoBreed: ndpi_protocol_breed_t,
        protoId: u_int16_t,
        protoName: *mut libc::c_char,
        protoCategory: ndpi_protocol_category_t,
        tcpDefPorts: *mut ndpi_port_range,
        udpDefPorts: *mut ndpi_port_range,
    );
}
extern "C" {
    pub fn ndpi_int_reset_protocol(flow: *mut ndpi_flow_struct);
}
extern "C" {
    pub fn ndpi_packet_src_ip_eql(
        packet: *const ndpi_packet_struct,
        ip: *const ndpi_ip_addr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_packet_dst_ip_eql(
        packet: *const ndpi_packet_struct,
        ip: *const ndpi_ip_addr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_packet_src_ip_get(packet: *const ndpi_packet_struct, ip: *mut ndpi_ip_addr_t);
}
extern "C" {
    pub fn ndpi_packet_dst_ip_get(packet: *const ndpi_packet_struct, ip: *mut ndpi_ip_addr_t);
}
extern "C" {
    pub fn ndpi_parse_ip_string(
        ip_str: *const libc::c_char,
        parsed_ip: *mut ndpi_ip_addr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_get_ip_string(
        ip: *const ndpi_ip_addr_t,
        buf: *mut libc::c_char,
        buf_len: u_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_is_ipv6(ip: *const ndpi_ip_addr_t) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_get_proto_by_id(
        ndpi_mod: *mut ndpi_detection_module_struct,
        id: u_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_get_proto_by_name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        name: *const libc::c_char,
    ) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_guess_protocol_id(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        proto: u_int8_t,
        sport: u_int16_t,
        dport: u_int16_t,
        user_defined_proto: *mut u_int8_t,
    ) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_is_proto(proto: ndpi_protocol, p: u_int16_t) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_get_lower_proto(p: ndpi_protocol) -> u_int16_t;
}
extern "C" {
    #[doc = " Checks when the @p payload starts with the string literal @p str.\n When the string is larger than the payload, check fails.\n @return non-zero if check succeeded"]
    pub fn ndpi_match_prefix(
        payload: *const u_int8_t,
        payload_len: usize,
        str_: *const libc::c_char,
        str_len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_handle_ipv6_extension_headers(
        l3len: u_int16_t,
        l4ptr: *mut *const u_int8_t,
        l4len: *mut u_int16_t,
        nxt_hdr: *mut u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_set_risk(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        r: ndpi_risk_enum,
    );
}
extern "C" {
    pub fn ndpi_isset_risk(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        r: ndpi_risk_enum,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_is_printable_string(str_: *mut libc::c_char, len: usize) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_entropy(buf: *const u_int8_t, len: usize) -> f32;
}
extern "C" {
    pub fn ndpi_hostname_sni_set(
        flow: *mut ndpi_flow_struct,
        value: *const u_int8_t,
        value_len: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Check if a string is encoded with punycode\n ( https://tools.ietf.org/html/rfc3492 )\n\n @par    buff = pointer to the string to ckeck\n @par    len  = len of the string\n @return 1 if the string is punycoded;\n         else 0\n"]
    pub fn ndpi_check_punycode_string(buff: *mut libc::c_char, len: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the size of the flow struct\n\n @return the size of the flow struct\n"]
    pub fn ndpi_detection_get_sizeof_ndpi_flow_struct() -> u_int32_t;
}
extern "C" {
    #[doc = " Get the size of the flow tcp struct\n\n @return the size of the flow tcp struct\n"]
    pub fn ndpi_detection_get_sizeof_ndpi_flow_tcp_struct() -> u_int32_t;
}
extern "C" {
    #[doc = " Get the size of the flow udp struct\n\n @return the size of the flow udp struct\n"]
    pub fn ndpi_detection_get_sizeof_ndpi_flow_udp_struct() -> u_int32_t;
}
extern "C" {
    pub fn ndpi_match_string_value(
        _automa: *mut libc::c_void,
        string_to_match: *mut libc::c_char,
        match_len: u_int,
        num: *mut u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " nDPI personal allocation and free functions"]
    pub fn ndpi_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_calloc(count: libc::c_ulong, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_realloc(
        ptr: *mut libc::c_void,
        old_size: usize,
        new_size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_free(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn ndpi_flow_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_flow_free(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn ndpi_get_tot_allocated_memory() -> u_int32_t;
}
extern "C" {
    #[doc = " Search the first occurrence of substring -find- in -s-\n The search is limited to the first -slen- characters of the string\n\n @par    s     = string to parse\n @par    find  = string to match with -s-\n @par    slen  = max length to match between -s- and -find-\n @return a pointer to the beginning of the located substring;\n         NULL if the substring is not found\n"]
    pub fn ndpi_strnstr(
        s: *const libc::c_char,
        find: *const libc::c_char,
        slen: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Same as ndpi_strnstr but case insensitive\n\n @par    s     = string to parse\n @par    find  = string to match with -s-\n @par    slen  = max length to match between -s- and -find-\n @return a pointer to the beginning of the located substring;\n         NULL if the substring is not found\n"]
    pub fn ndpi_strncasestr(
        s: *const libc::c_char,
        find: *const libc::c_char,
        slen: usize,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Returns the nDPI protocol id for IP-based protocol detection\n\n @par    ndpi_struct  = the struct created for the protocol detection\n @par    pin          = IP host address (MUST BE in network byte order):\n                        See man(7) ip for details\n @return the nDPI protocol ID\n"]
    pub fn ndpi_network_ptree_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        pin: *mut in_addr,
    ) -> u_int16_t;
}
extern "C" {
    #[doc = " Returns the nDPI protocol id for IP+port-based protocol detection\n\n @par    ndpi_struct  = the struct created for the protocol detection\n @par    pin          = IP host address (MUST BE in network byte order):\n                        See man(7) ip for details\n @par    port         = The port (MUST BE in network byte order) or\n                        0 if ignored\n @return the nDPI protocol ID\n"]
    pub fn ndpi_network_port_ptree_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        pin: *mut in_addr,
        port: u_int16_t,
    ) -> u_int16_t;
}
extern "C" {
    #[doc = " Init single protocol match\n\n @par ndpi_mod  = the struct created for the protocol detection\n @par match     = the struct passed to match the protocol\n"]
    pub fn ndpi_init_protocol_match(
        ndpi_mod: *mut ndpi_detection_module_struct,
        match_: *mut ndpi_protocol_match,
    );
}
extern "C" {
    #[doc = " Returns a new initialized detection module\n Note that before you can use it you can still load\n hosts and do other things. As soon as you are ready to use\n it do not forget to call first ndpi_finalize_initialization()\n\n You can call this function multiple times, (i.e. to create multiple\n indipendent detection contexts) but all these calls MUST NOT run\n in parallel\n\n @par prefs = load preferences\n @return  the initialized detection module\n"]
    pub fn ndpi_init_detection_module(prefs: ndpi_init_prefs) -> *mut ndpi_detection_module_struct;
}
extern "C" {
    #[doc = " Completes the initialization (2nd step)\n\n @par ndpi_str = the struct created for the protocol detection\n"]
    pub fn ndpi_finalize_initialization(ndpi_str: *mut ndpi_detection_module_struct);
}
extern "C" {
    #[doc = " Frees the dynamic memory allocated members in the specified flow\n\n @par flow  = the flow struct which dynamic allocated members should be deallocated\n"]
    pub fn ndpi_free_flow_data(flow: *mut ndpi_flow_struct);
}
extern "C" {
    #[doc = " Frees the dynamic memory allocated members in the specified flow and the flow struct itself\n\n @par flow  = the flow struct and its dynamic allocated members that should be deallocated\n"]
    pub fn ndpi_free_flow(flow: *mut ndpi_flow_struct);
}
extern "C" {
    #[doc = " Enables cache support.\n In nDPI is used for some protocol (i.e. Skype)\n\n @par ndpi_mod  = the struct created for the protocol detection\n @par host      = string for the host name\n @par port      = unsigned int for the port number\n"]
    pub fn ndpi_enable_cache(
        ndpi_mod: *mut ndpi_detection_module_struct,
        host: *mut libc::c_char,
        port: u_int,
    );
}
extern "C" {
    #[doc = " Destroys the detection module\n\n @par ndpi_struct  = the struct to clearing for the detection module\n"]
    pub fn ndpi_exit_detection_module(ndpi_struct: *mut ndpi_detection_module_struct);
}
extern "C" {
    #[doc = " Sets a single protocol bitmask\n This function does not increment the index of the callback_buffer\n\n @par label                    = string for the protocol name\n @par ndpi_struct              = the detection module\n @par detection_bitmask        = the protocol bitmask\n @par idx                      = the index of the callback_buffer\n @par func                     = function pointer of the protocol search\n @par ndpi_selection_bitmask   = the protocol selected bitmask\n @par b_save_bitmask_unknow    = if set as \"true\" save the detection bitmask as unknow\n @par b_add_detection_bitmask  = if set as \"true\" add the protocol bitmask to the detection bitmask\n"]
    pub fn ndpi_set_bitmask_protocol_detection(
        label: *mut libc::c_char,
        ndpi_struct: *mut ndpi_detection_module_struct,
        detection_bitmask: *const ndpi_protocol_bitmask_struct_t,
        idx: u_int32_t,
        ndpi_protocol_id: u_int16_t,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ndpi_detection_module_struct,
                flow: *mut ndpi_flow_struct,
            ),
        >,
        ndpi_selection_bitmask: u_int32_t,
        b_save_bitmask_unknow: u_int8_t,
        b_add_detection_bitmask: u_int8_t,
    );
}
extern "C" {
    #[doc = " Sets the protocol bitmask2\n\n @par ndpi_struct        = the detection module\n @par detection_bitmask  = the protocol bitmask to set\n"]
    pub fn ndpi_set_protocol_detection_bitmask2(
        ndpi_struct: *mut ndpi_detection_module_struct,
        detection_bitmask: *const ndpi_protocol_bitmask_struct_t,
    );
}
extern "C" {
    #[doc = "  Function to be called before we give up with detection for a given flow.\n  This function reduces the NDPI_UNKNOWN_PROTOCOL detection\n\n @par    ndpi_struct  = the detection module\n @par    flow         = the flow given for the detection module\n @par    enable_guess = guess protocol if unknown\n @par    protocol_was_guessed = 1 if the protocol was guesses (requires enable_guess = 1), 0 otherwise\n @return the detected protocol even if the flow is not completed;\n"]
    pub fn ndpi_detection_giveup(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        enable_guess: u_int8_t,
        protocol_was_guessed: *mut u_int8_t,
    ) -> ndpi_protocol;
}
extern "C" {
    #[doc = " Processes an extra packet in order to get more information for a given protocol\n (like SSL getting both client and server certificate even if we already know after\n seeing the client certificate what the protocol is)\n\n @par    ndpi_struct    = the detection module\n @par    flow           = pointer to the connection state machine\n @par    packet         = unsigned char pointer to the Layer 3 (IP header)\n @par    packetlen      = the length of the packet\n @par    packet_time_ms = the current timestamp for the packet (expressed in msec)\n @return void\n"]
    pub fn ndpi_process_extra_packet(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        packet: *const libc::c_uchar,
        packetlen: libc::c_ushort,
        packet_time_ms: u_int64_t,
    );
}
extern "C" {
    #[doc = " Processes one packet and returns the ID of the detected protocol.\n This is the MAIN PACKET PROCESSING FUNCTION.\n\n @par    ndpi_struct    = the detection module\n @par    flow           = pointer to the connection state machine\n @par    packet         = unsigned char pointer to the Layer 3 (IP header)\n @par    packetlen      = the length of the packet\n @par    packet_time_ms = the current timestamp for the packet (expressed in msec)\n @return the detected ID of the protocol\n"]
    pub fn ndpi_detection_process_packet(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        packet: *const libc::c_uchar,
        packetlen: libc::c_ushort,
        packet_time_ms: u_int64_t,
    ) -> ndpi_protocol;
}
extern "C" {
    #[doc = " Get the main protocol of the passed flows for the detected module\n\n\n @par    ndpi_struct  = the detection module\n @par    flow         = the flow given for the detection module\n @return the ID of the master protocol detected\n"]
    pub fn ndpi_get_flow_masterprotocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> u_int16_t;
}
extern "C" {
    #[doc = " API call that is called internally by ndpi_detection_process_packet or by apps\n that want to avoid calling ndpi_detection_process_packet as they have already\n parsed the packet and thus want to avoid this.\n\n\n @par    ndpi_struct              = the detection module\n @par    flow                     = the flow given for the detection module\n @par    ndpi_selection_bitmask   = the protocol selected bitmask\n @return number of protocol dissector that have been tried (0 = no more dissectors)\n"]
    pub fn ndpi_check_flow_func(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        ndpi_selection_packet: *mut u_int32_t,
    ) -> u_int32_t;
}
extern "C" {
    #[doc = " Query the pointer to the layer 4 packet\n\n @par    l3 = pointer to the layer 3 data\n @par    l3_len = length of the layer 3 data\n @par    l4_return = address to the pointer of the layer 4 data if return value == 0, else undefined\n @par    l4_len_return = length of the layer 4 data if return value == 0, else undefined\n @par    l4_protocol_return = protocol of the layer 4 data if return value == 0, undefined otherwise\n @par    flags = limit operation on ipv4 or ipv6 packets. Possible values: NDPI_DETECTION_ONLY_IPV4 - NDPI_DETECTION_ONLY_IPV6 - 0 (any)\n @return 0 if layer 4 data could be found correctly;\nelse != 0\n"]
    pub fn ndpi_detection_get_l4(
        l3: *const u_int8_t,
        l3_len: u_int16_t,
        l4_return: *mut *const u_int8_t,
        l4_len_return: *mut u_int16_t,
        l4_protocol_return: *mut u_int8_t,
        flags: u_int32_t,
    ) -> u_int8_t;
}
extern "C" {
    #[doc = " Search and return the protocol based on matched ports\n\n @par    ndpi_struct  = the detection module\n @par    shost        = source address in host byte order\n @par    sport        = source port number\n @par    dhost        = destination address in host byte order\n @par    dport        = destination port number\n @return the struct ndpi_protocol that match the port base protocol\n"]
    pub fn ndpi_find_port_based_protocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        shost: u_int32_t,
        sport: u_int16_t,
        dhost: u_int32_t,
        dport: u_int16_t,
    ) -> ndpi_protocol;
}
extern "C" {
    #[doc = " Search and return the protocol guessed that is undetected\n\n @par    ndpi_struct  = the detection module\n @par    flow         = the flow we're trying to guess, NULL if not available\n @par    proto        = the l4 protocol number\n @par    shost        = source address in host byte order\n @par    sport        = source port number\n @par    dhost        = destination address in host byte order\n @par    dport        = destination port number\n @return the struct ndpi_protocol that match the port base protocol\n"]
    pub fn ndpi_guess_undetected_protocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        proto: u_int8_t,
        shost: u_int32_t,
        sport: u_int16_t,
        dhost: u_int32_t,
        dport: u_int16_t,
    ) -> ndpi_protocol;
}
extern "C" {
    #[doc = " Check if the string passed match with a protocol\n\n @par    ndpi_struct         = the detection module\n @par    string_to_match     = the string to match\n @par    string_to_match_len = the length of the string\n @par    ret_match           = completed returned match information\n @return the ID of the matched subprotocol;\n         -1 if automa is not finalized;\n         -2 if automa==NULL or string_to_match==NULL or empty string_to_match\n"]
    pub fn ndpi_match_string_subprotocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        string_to_match: *mut libc::c_char,
        string_to_match_len: u_int,
        ret_match: *mut ndpi_protocol_match_result,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check if the host passed match with a protocol\n\n @par    ndpi_struct         = the detection module\n @par    flow                = the flow where match the host\n @par    string_to_match     = the string to match\n @par    string_to_match_len = the length of the string\n @par    ret_match           = completed returned match information\n @par    master_protocol_id  = value of the ID associated to the master protocol detected\n @return the ID of the matched subprotocol\n"]
    pub fn ndpi_match_host_subprotocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        string_to_match: *mut libc::c_char,
        string_to_match_len: u_int,
        ret_match: *mut ndpi_protocol_match_result,
        master_protocol_id: u_int16_t,
    ) -> u_int16_t;
}
extern "C" {
    #[doc = " Check if the string content passed match with a protocol\n\n @par    ndpi_struct         = the detection module\n @par    flow                = the flow where match the host\n @par    subprotocol_id      = subprotocol id"]
    pub fn ndpi_check_subprotocol_risk(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        subprotocol_id: u_int16_t,
    );
}
extern "C" {
    #[doc = " Exclude protocol from search\n\n @par    ndpi_struct         = the detection module\n @par    flow                = the flow where match the host\n @par    master_protocol_id  = value of the ID associated to the master protocol detected\n"]
    pub fn ndpi_exclude_protocol(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        master_protocol_id: u_int16_t,
        _file: *const libc::c_char,
        _func: *const libc::c_char,
        _line: libc::c_int,
    );
}
extern "C" {
    #[doc = " Check if the string -bigram_to_match- match with a bigram of -automa-\n\n @par     ndpi_mod         = the detection module\n @par     automa           = the struct ndpi_automa for the bigram\n @par     bigram_to_match  = the bigram string to match\n @return  0\n"]
    pub fn ndpi_match_bigram(bigram_to_match: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Write the protocol name in the buffer -buf- as master_protocol.protocol\n\n @par     ndpi_mod      = the detection module\n @par     proto         = the struct ndpi_protocol contain the protocols name\n @par     buf           = the buffer to write the name of the protocols\n @par     buf_len       = the length of the buffer\n @return  the buffer contains the master_protocol and protocol name\n"]
    pub fn ndpi_protocol2name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        proto: ndpi_protocol,
        buf: *mut libc::c_char,
        buf_len: u_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Same as ndpi_protocol2name() with the difference that the numeric protocol\n name is returned\n\n @par     ndpi_mod      = the detection module\n @par     proto         = the struct ndpi_protocol contain the protocols name\n @par     buf           = the buffer to write the name of the protocols\n @par     buf_len       = the length of the buffer\n @return  the buffer contains the master_protocol and protocol name\n"]
    pub fn ndpi_protocol2id(
        ndpi_mod: *mut ndpi_detection_module_struct,
        proto: ndpi_protocol,
        buf: *mut libc::c_char,
        buf_len: u_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Find out if a given category is custom/user-defined\n\n @par     category      = the category associated to the protocol\n @return  1 if this is a custom user category, 0 otherwise\n"]
    pub fn ndpi_is_custom_category(category: ndpi_protocol_category_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Overwrite a protocol category defined by nDPI with the custom category\n\n @par     ndpi_mod      = the detection module\n @par     protoId       = the protocol identifier to overwrite\n @par     breed         = the breed to be associated to the protocol\n"]
    pub fn ndpi_set_proto_breed(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
        breed: ndpi_protocol_breed_t,
    );
}
extern "C" {
    #[doc = " Overwrite a protocol category defined by nDPI with the custom category\n\n @par     ndpi_mod      = the detection module\n @par     protoId       = the protocol identifier to overwrite\n @par     category      = the category associated to the protocol\n"]
    pub fn ndpi_set_proto_category(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
        protoCategory: ndpi_protocol_category_t,
    );
}
extern "C" {
    #[doc = " Check if subprotocols of the specified master protocol are just\n informative (and not real)\n\n @par     mod           = the detection module\n @par     protoId       = the (master) protocol identifier to query\n @return  1 = the subprotocol is informative, 0 otherwise.\n"]
    pub fn ndpi_is_subprotocol_informative(
        ndpi_mod: *mut ndpi_detection_module_struct,
        protoId: u_int16_t,
    ) -> u_int8_t;
}
extern "C" {
    #[doc = " Set hostname-based protocol\n\n @par ndpi_mod          = the detection module\n @par flow              = the flow to which this communication belongs to\n @par master_protocol   = the master protocol for this flow\n @par name              = the host name\n @par name_len          = length of the host name\n"]
    pub fn ndpi_match_hostname_protocol(
        ndpi_mod: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        master_protocol: u_int16_t,
        name: *mut libc::c_char,
        name_len: u_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get protocol category as string\n\n @par     mod           = the detection module\n @par     category      = the category associated to the protocol\n @return  the string name of the category\n"]
    pub fn ndpi_category_get_name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        category: ndpi_protocol_category_t,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get classification confidence as string\n\n @par     confidence      = the confidence value\n @return  the string name of the confidence result\n"]
    pub fn ndpi_confidence_get_name(confidence: ndpi_confidence_t) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Set protocol category string\n\n @par     mod           = the detection module\n @par     category      = the category associated to the protocol\n @paw     name          = the string name of the category\n"]
    pub fn ndpi_category_set_name(
        ndpi_mod: *mut ndpi_detection_module_struct,
        category: ndpi_protocol_category_t,
        name: *mut libc::c_char,
    );
}
extern "C" {
    #[doc = " Get protocol category\n\n @par     ndpi_mod      = the detection module\n @par     proto         = the struct ndpi_protocol contain the protocols name\n @return  the protocol category"]
    pub fn ndpi_get_proto_category(
        ndpi_mod: *mut ndpi_detection_module_struct,
        proto: ndpi_protocol,
    ) -> ndpi_protocol_category_t;
}
extern "C" {
    #[doc = " Get the protocol name associated to the ID\n\n @par     mod           = the detection module\n @par     proto_id      = the ID of the protocol\n @return  the buffer contains the master_protocol and protocol name\n"]
    pub fn ndpi_get_proto_name(
        mod_: *mut ndpi_detection_module_struct,
        proto_id: u_int16_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Return the protocol breed ID associated to the protocol\n\n @par     ndpi_struct   = the detection module\n @par     proto         = the ID of the protocol\n @return  the breed ID associated to the protocol\n"]
    pub fn ndpi_get_proto_breed(
        ndpi_struct: *mut ndpi_detection_module_struct,
        proto: u_int16_t,
    ) -> ndpi_protocol_breed_t;
}
extern "C" {
    #[doc = " Return the string name of the protocol breed\n\n @par     ndpi_struct   = the detection module\n @par     breed_id      = the breed ID associated to the protocol\n @return  the string name of the breed ID\n"]
    pub fn ndpi_get_proto_breed_name(
        ndpi_struct: *mut ndpi_detection_module_struct,
        breed_id: ndpi_protocol_breed_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Return the ID of the protocol\n\n @par     ndpi_mod   = the detection module\n @par     proto      = the protocol name\n @return  the ID of the protocol\n"]
    pub fn ndpi_get_protocol_id(
        ndpi_mod: *mut ndpi_detection_module_struct,
        proto: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the ID of the category\n\n @par     ndpi_mod   = the detection module\n @par     proto      = the category name\n @return  the ID of the category\n"]
    pub fn ndpi_get_category_id(
        ndpi_mod: *mut ndpi_detection_module_struct,
        cat: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Write the list of the supported protocols\n\n @par  ndpi_mod = the detection module"]
    pub fn ndpi_dump_protocols(mod_: *mut ndpi_detection_module_struct);
}
extern "C" {
    #[doc = " Generate Options list used in OPNsense firewall plugin\n\n @par  opt = The Option list to generate"]
    pub fn ndpi_generate_options(opt: u_int);
}
extern "C" {
    #[doc = " Write the list of the scores and their associated risks\n\n @par  ndpi_mod = the detection module"]
    pub fn ndpi_dump_risks_score();
}
extern "C" {
    #[doc = " Read a file and load the protocols\n\n Format: <tcp|udp>:<port>,<tcp|udp>:<port>,.....@<proto>\n\n Example:\n tcp:80,tcp:3128@HTTP\n udp:139@NETBIOS\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else\n"]
    pub fn ndpi_load_protocols_file(
        ndpi_mod: *mut ndpi_detection_module_struct,
        path: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add an IP-address based risk mask\n\n @par     ndpi_mod = the detection module\n @par     ip       = the IP address for which you wanna set the mask\n @par     mask     = the IP risk mask\n @return  0 if the rule is loaded correctly;\n          -1 else"]
    pub fn ndpi_add_ip_risk_mask(
        ndpi_mod: *mut ndpi_detection_module_struct,
        ip: *mut libc::c_char,
        mask: ndpi_risk,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a host-address based risk mask\n\n @par     ndpi_mod = the detection module\n @par     host     = the hostname/domain for which you wanna set the mask\n @par     mask     = the host risk mask\n @return  0 if the rule is loaded correctly;\n          -1 else"]
    pub fn ndpi_add_host_risk_mask(
        ndpi_mod: *mut ndpi_detection_module_struct,
        host: *mut libc::c_char,
        mask: ndpi_risk,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a trusted certificate issuer DN\n\n @par     ndpi_mod = the detection module\n @par     dn       = the issuer DN as it appears in the certificate (example \"CN=813845657003339838, O=Code42, OU=TEST, ST=MN, C=US\")\n @return  0 if the rule is loaded correctly; < 0 in case an error is detected"]
    pub fn ndpi_add_trusted_issuer_dn(
        ndpi_mod: *mut ndpi_detection_module_struct,
        dn: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read a file and load the categories\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_categories_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read a file and load the list of risky domains\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_risk_domain_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read a file and load the list of malicious JA3 signatures\n\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_malicious_ja3_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read a file and load the list of malicious SSL certificate SHA1 fingerprints.\n @par     ndpi_mod = the detection module\n @par     path     = the path of the file\n @return  0 if the file is loaded correctly;\n          -1 else"]
    pub fn ndpi_load_malicious_sha1_file(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the total number of the supported protocols\n\n @par     ndpi_mod = the detection module\n @return  the number of protocols\n"]
    pub fn ndpi_get_num_supported_protocols(ndpi_mod: *mut ndpi_detection_module_struct) -> u_int;
}
extern "C" {
    #[doc = " Get the nDPI version release\n\n @return the NDPI_GIT_RELEASE\n"]
    pub fn ndpi_revision() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Set the automa for the protocol search\n\n @par ndpi_struct = the detection module\n @par automa      = the automa to match\n"]
    pub fn ndpi_set_automa(
        ndpi_struct: *mut ndpi_detection_module_struct,
        automa: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Retrieve information for HTTP flows\n\n @par     ndpi_mod = the detection module\n @par     flow     = the detected flow\n @return  the HTTP method information about the flow\n"]
    pub fn ndpi_get_http_method(
        ndpi_mod: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> ndpi_http_method;
}
extern "C" {
    #[doc = " Get the HTTP url\n\n @par     ndpi_mod = the detection module\n @par     flow     = the detected flow\n @return  the HTTP method information about the flow\n"]
    pub fn ndpi_get_http_url(
        ndpi_mod: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the HTTP content-type\n\n @par     ndpi_mod = the detection module\n @par     flow     = the detected flow\n @return  the HTTP method information about the flow\n"]
    pub fn ndpi_get_http_content_type(
        ndpi_mod: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Check if the flow could be detected as TOR protocol\n\n @par     ndpi_struct = the detection module\n @par     flow = the detected flow\n @par     certificate = the SSL/TLS certificate\n @return  1 if the flow is TOR;\n          0 else\n"]
    pub fn ndpi_is_tls_tor(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        certificate: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Init Aho-Corasick automata\n\n @return  The requested automata, or NULL if an error occurred\n"]
    pub fn ndpi_init_automa() -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Free Aho-Corasick automata allocated with ndpi_init_automa();\n\n @par     The automata initialized with ndpi_init_automa();\n"]
    pub fn ndpi_free_automa(_automa: *mut libc::c_void);
}
extern "C" {
    #[doc = " Add a string to match to an automata\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search (malloc'ed memory)\n @par     The number associated with this string\n @return  0 in case of no error, or -1 if an error occurred.\n"]
    pub fn ndpi_add_string_value_to_automa(
        _automa: *mut libc::c_void,
        str_: *mut libc::c_char,
        num: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add a string to match to an automata. Same as ndpi_add_string_value_to_automa() with num set to 1\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search (malloc'ed memory)\n @return  0 in case of no error, or -1 if an error occurred.\n"]
    pub fn ndpi_add_string_to_automa(
        _automa: *mut libc::c_void,
        str_: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Finalize the automa (necessary before start searching)\n\n @par     The automata initialized with ndpi_init_automa();\n"]
    pub fn ndpi_finalize_automa(_automa: *mut libc::c_void);
}
extern "C" {
    #[doc = " Add a string to match to an automata\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search\n @return  0 in case of match, or -1 if no match, or -2 if an error occurred.\n"]
    pub fn ndpi_match_string(
        _automa: *mut libc::c_void,
        string_to_match: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_load_ip_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_address_and_mask: *const libc::c_char,
        category: ndpi_protocol_category_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_load_hostname_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        name_to_add: *const libc::c_char,
        category: ndpi_protocol_category_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_load_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ip_or_name: *const libc::c_char,
        category: ndpi_protocol_category_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_enable_loaded_categories(
        ndpi_struct: *mut ndpi_detection_module_struct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_fill_ip_protocol_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        saddr: u_int32_t,
        daddr: u_int32_t,
        ret: *mut ndpi_protocol,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_match_custom_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        name: *mut libc::c_char,
        name_len: u_int,
        id: *mut ndpi_protocol_category_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_fill_protocol_category(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        ret: *mut ndpi_protocol,
    );
}
extern "C" {
    pub fn ndpi_get_custom_category_match(
        ndpi_struct: *mut ndpi_detection_module_struct,
        name_or_ip: *mut libc::c_char,
        name_len: u_int,
        id: *mut ndpi_protocol_category_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_set_detection_preferences(
        ndpi_mod: *mut ndpi_detection_module_struct,
        pref: ndpi_detection_preference,
        value: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_get_l4_proto_info(
        ndpi_struct: *mut ndpi_detection_module_struct,
        ndpi_proto_id: u_int16_t,
    ) -> ndpi_l4_proto_info;
}
extern "C" {
    pub fn ndpi_get_l4_proto_name(proto: ndpi_l4_proto_info) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_get_upper_proto(proto: ndpi_protocol) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_get_proto_defaults(
        ndpi_mod: *mut ndpi_detection_module_struct,
    ) -> *mut ndpi_proto_defaults_t;
}
extern "C" {
    pub fn ndpi_get_ndpi_num_supported_protocols(
        ndpi_mod: *mut ndpi_detection_module_struct,
    ) -> u_int;
}
extern "C" {
    pub fn ndpi_get_ndpi_num_custom_protocols(ndpi_mod: *mut ndpi_detection_module_struct)
        -> u_int;
}
extern "C" {
    pub fn ndpi_get_ndpi_detection_module_size() -> u_int;
}
extern "C" {
    pub fn ndpi_set_log_level(ndpi_mod: *mut ndpi_detection_module_struct, l: u_int);
}
extern "C" {
    pub fn ndpi_set_debug_bitmask(
        ndpi_mod: *mut ndpi_detection_module_struct,
        debug_bitmask: ndpi_protocol_bitmask_struct_t,
    );
}
extern "C" {
    pub fn ndpi_lru_cache_init(num_entries: u_int32_t) -> *mut ndpi_lru_cache;
}
extern "C" {
    pub fn ndpi_lru_free_cache(c: *mut ndpi_lru_cache);
}
extern "C" {
    pub fn ndpi_lru_find_cache(
        c: *mut ndpi_lru_cache,
        key: u_int32_t,
        value: *mut u_int16_t,
        clean_key_when_found: u_int8_t,
    ) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_lru_add_to_cache(c: *mut ndpi_lru_cache, key: u_int32_t, value: u_int16_t);
}
extern "C" {
    #[doc = " Find a protocol id associated with a string automata\n\n @par     The automata initialized with ndpi_init_automa();\n @par     The (sub)string to search\n @par     The (sub)string length\n @par     The protocol id associated with the matched string or 0 id not found.\n @return  0 in case of match, or -1 if no match, or -2 if an error occurred.\n"]
    pub fn ndpi_match_string_protocol_id(
        _automa: *mut libc::c_void,
        string_to_match: *mut libc::c_char,
        match_len: u_int,
        protocol_id: *mut u_int16_t,
        category: *mut ndpi_protocol_category_t,
        breed: *mut ndpi_protocol_breed_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Specifies the threshold used to trigger the NDPI_TLS_CERTIFICATE_ABOUT_TO_EXPIRE\n flow risk that by default is set to 30 days\n\n @par    ndpi_struct  = the struct created for the protocol detection\n @par    days         = the number of days threshold for emitting the alert\n"]
    pub fn ndpi_set_tls_cert_expire_days(
        ndpi_str: *mut ndpi_detection_module_struct,
        days: u_int8_t,
    );
}
extern "C" {
    pub fn ndpi_get_api_version() -> u_int16_t;
}
extern "C" {
    pub fn ndpi_get_gcrypt_version() -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_flowv4_flow_hash(
        l4_proto: u_int8_t,
        src_ip: u_int32_t,
        dst_ip: u_int32_t,
        src_port: u_int16_t,
        dst_port: u_int16_t,
        icmp_type: u_int8_t,
        icmp_code: u_int8_t,
        hash_buf: *mut u_char,
        hash_buf_len: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_flowv6_flow_hash(
        l4_proto: u_int8_t,
        src_ip: *mut ndpi_in6_addr,
        dst_ip: *mut ndpi_in6_addr,
        src_port: u_int16_t,
        dst_port: u_int16_t,
        icmp_type: u_int8_t,
        icmp_code: u_int8_t,
        hash_buf: *mut u_char,
        hash_buf_len: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_extra_dissection_possible(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_is_safe_ssl_cipher(cipher: u_int32_t) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_cipher2str(cipher: u_int32_t) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_tunnel2str(tt: ndpi_packet_tunnel) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_guess_host_protocol_id(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
    ) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_has_human_readeable_string(
        ndpi_struct: *mut ndpi_detection_module_struct,
        buffer: *mut libc::c_char,
        buffer_size: u_int,
        min_string_match_len: u_int8_t,
        outbuf: *mut libc::c_char,
        outbuf_len: u_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_get_flow_info(
        flow: *const ndpi_flow_struct,
        l7_protocol: *const ndpi_protocol,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_ssl_version2str(
        buf: *mut libc::c_char,
        buf_len: libc::c_int,
        version: u_int16_t,
        unknown_tls_version: *mut u_int8_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_netbios_name_interpret(
        in_: *mut u_char,
        in_len: u_int,
        out: *mut u_char,
        out_len: u_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_patchIPv6Address(str_: *mut libc::c_char);
}
extern "C" {
    pub fn ndpi_user_pwd_payload_copy(
        dest: *mut u_int8_t,
        dest_len: u_int,
        offset: u_int,
        src: *const u_int8_t,
        src_len: u_int,
    );
}
extern "C" {
    pub fn ndpi_base64_decode(src: *const u_char, len: usize, out_len: *mut usize) -> *mut u_char;
}
extern "C" {
    pub fn ndpi_base64_encode(
        bytes_to_encode: *const libc::c_uchar,
        in_len: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_string_sha1_hash(message: *const u8, len: usize, hash: *mut u_char);
}
extern "C" {
    pub fn ndpi_load_ipv4_ptree(
        ndpi_str: *mut ndpi_detection_module_struct,
        path: *const libc::c_char,
        protocol_id: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_dpi2json(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        l7_protocol: ndpi_protocol,
        serializer: *mut ndpi_serializer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_flow2json(
        ndpi_struct: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        ip_version: u_int8_t,
        l4_protocol: u_int8_t,
        src_v4: u_int32_t,
        dst_v4: u_int32_t,
        src_v6: *mut ndpi_in6_addr,
        dst_v6: *mut ndpi_in6_addr,
        src_port: u_int16_t,
        dst_port: u_int16_t,
        l7_protocol: ndpi_protocol,
        serializer: *mut ndpi_serializer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_md5(data: *const u_char, data_len: usize, hash: *mut u_char);
}
extern "C" {
    pub fn ndpi_quick_hash(str_: *mut libc::c_uchar, str_len: u_int) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_http_method2str(m: ndpi_http_method) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_http_str2method(
        method: *const libc::c_char,
        method_len: u_int16_t,
    ) -> ndpi_http_method;
}
extern "C" {
    pub fn ndpi_fill_prefix_v4(
        p: *mut ndpi_prefix_t,
        a: *const in_addr,
        b: libc::c_int,
        mb: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_fill_prefix_v6(
        prefix: *mut ndpi_prefix_t,
        addr: *const in6_addr,
        bits: libc::c_int,
        maxbits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_fill_prefix_mac(
        prefix: *mut ndpi_prefix_t,
        mac: *mut u_int8_t,
        bits: libc::c_int,
        maxbits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_patricia_new(maxbits: u_int16_t) -> *mut ndpi_patricia_tree_t;
}
extern "C" {
    pub fn ndpi_patricia_clone(from: *const ndpi_patricia_tree_t) -> *mut ndpi_patricia_tree_t;
}
extern "C" {
    pub fn ndpi_patricia_destroy(patricia: *mut ndpi_patricia_tree_t, func: ndpi_void_fn_t);
}
extern "C" {
    pub fn ndpi_patricia_search_exact(
        patricia: *mut ndpi_patricia_tree_t,
        prefix: *mut ndpi_prefix_t,
    ) -> *mut ndpi_patricia_node_t;
}
extern "C" {
    pub fn ndpi_patricia_search_best(
        patricia: *mut ndpi_patricia_tree_t,
        prefix: *mut ndpi_prefix_t,
    ) -> *mut ndpi_patricia_node_t;
}
extern "C" {
    pub fn ndpi_patricia_lookup(
        patricia: *mut ndpi_patricia_tree_t,
        prefix: *mut ndpi_prefix_t,
    ) -> *mut ndpi_patricia_node_t;
}
extern "C" {
    pub fn ndpi_patricia_walk_tree_inorder(
        patricia: *mut ndpi_patricia_tree_t,
        func: ndpi_void_fn3_t,
        data: *mut libc::c_void,
    ) -> usize;
}
extern "C" {
    pub fn ndpi_patricia_walk_inorder(
        node: *mut ndpi_patricia_node_t,
        func: ndpi_void_fn3_t,
        data: *mut libc::c_void,
    ) -> usize;
}
extern "C" {
    pub fn ndpi_patricia_remove(
        patricia: *mut ndpi_patricia_tree_t,
        node: *mut ndpi_patricia_node_t,
    );
}
extern "C" {
    pub fn ndpi_patricia_set_node_u64(node: *mut ndpi_patricia_node_t, value: u_int64_t);
}
extern "C" {
    pub fn ndpi_patricia_get_node_u64(node: *mut ndpi_patricia_node_t) -> u_int64_t;
}
extern "C" {
    pub fn ndpi_patricia_set_node_data(node: *mut ndpi_patricia_node_t, data: *mut libc::c_void);
}
extern "C" {
    pub fn ndpi_patricia_get_node_data(node: *mut ndpi_patricia_node_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ndpi_patricia_get_node_prefix(node: *mut ndpi_patricia_node_t) -> *mut ndpi_prefix_t;
}
extern "C" {
    pub fn ndpi_patricia_get_node_bits(node: *mut ndpi_patricia_node_t) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_patricia_get_maxbits(tree: *mut ndpi_patricia_tree_t) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_ptree_create() -> *mut ndpi_ptree_t;
}
extern "C" {
    pub fn ndpi_ptree_insert(
        tree: *mut ndpi_ptree_t,
        addr: *const ndpi_ip_addr_t,
        bits: u_int8_t,
        user_data: u_int64_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_ptree_match_addr(
        tree: *mut ndpi_ptree_t,
        addr: *const ndpi_ip_addr_t,
        user_data: *mut u_int64_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_ptree_destroy(tree: *mut ndpi_ptree_t);
}
extern "C" {
    pub fn ndpi_htonll(v: u_int64_t) -> u_int64_t;
}
extern "C" {
    pub fn ndpi_ntohll(v: u_int64_t) -> u_int64_t;
}
extern "C" {
    pub fn ndpi_is_valid_protoId(protoId: u_int16_t) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_is_encrypted_proto(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: ndpi_protocol,
    ) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_check_dga_name(
        ndpi_str: *mut ndpi_detection_module_struct,
        flow: *mut ndpi_flow_struct,
        name: *mut libc::c_char,
        is_hostname: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a serializer handle (allocated by the caller).\n @param serializer The serializer handle\n @param fmt The serialization format (ndpi_serialization_format_json, ndpi_serialization_format_tlv, ndpi_serialization_format_csv)\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_init_serializer(
        serializer: *mut ndpi_serializer,
        fmt: ndpi_serialization_format,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a serializer handle. Same as ndpi_init_serializer, but with some low-level settings.\n @param serializer The serializer handle\n @param fmt The serialization format (ndpi_serialization_format_json, ndpi_serialization_format_tlv, ndpi_serialization_format_csv)\n @param buffer_size The initial internal buffer_size\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_init_serializer_ll(
        serializer: *mut ndpi_serializer,
        fmt: ndpi_serialization_format,
        buffer_size: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Release all allocated data structure.\n @param serializer The serializer handle"]
    pub fn ndpi_term_serializer(serializer: *mut ndpi_serializer);
}
extern "C" {
    #[doc = " Reset the serializer (cleanup the internal buffer to start a new serialization)\n @param serializer The serializer handle"]
    pub fn ndpi_reset_serializer(serializer: *mut ndpi_serializer);
}
extern "C" {
    #[doc = " Hint to not create the header (used to avoid creaign the header when not used)\n @param serializer The serializer handle"]
    pub fn ndpi_serializer_skip_header(serializer: *mut ndpi_serializer);
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 32-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_uint32(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 64-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_uint64(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: u_int64_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 32-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_int32(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: i32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a 64-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_int64(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The float value format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_float(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: f32,
        format: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_string(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a 32-bit unsigned int key and a boolean value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_uint32_boolean(
        serializer: *mut ndpi_serializer,
        key: u_int32_t,
        value: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and a 32-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_int32(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        value: i32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a 32-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_int32(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: i32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and a 64-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_int64(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        value: i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a 64-bit signed int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_int64(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: i64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and a 32-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_uint32(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        value: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a 32-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_uint32(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The float format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_uint32_format(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: u_int32_t,
        format: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and a 64-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_uint64(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        value: u_int64_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a 64-bit unsigned int value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_uint64(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: u_int64_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and an unterminated string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_binary(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        _value: *const libc::c_char,
        vlen: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_string(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and an unterminated string value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_binary(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        _value: *const libc::c_char,
        vlen: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a raw value (this is a string which is added to the JSON without any quote or escaping)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param vlen The value length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_raw(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        _value: *const libc::c_char,
        vlen: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @param format The float format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_float(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        value: f32,
        format: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a a float value\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @param format The float format\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_float(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: f32,
        format: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an unterminated string key and a boolean value (JSON/CSV only, not supported by TLV)\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_binary_boolean(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
        value: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a string key and a boolean value (JSON/CSV only, not supported by TLV)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_string_boolean(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        value: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize a raw record in an array (this is a low-level function and its use is not recommended)\n @param serializer The serializer handle\n @param record The record value\n @param record_len The record length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_raw_record(
        _serializer: *mut ndpi_serializer,
        record: *mut u_char,
        record_len: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize an End-Of-Record (the current object becomes is terminated and added to an array,\n and a new object is created where the next items will be added)\n @param serializer The serializer handle\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_end_of_record(serializer: *mut ndpi_serializer) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize the start of a list with an unterminated string key, where the next serialized items\n will be added (note: keys for the new items are ignored)\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_list_binary(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize the start of a list, where the next serialized items will be added (note: keys for\n the new items are ignored)\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_list(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize the end of a list\n @param serializer The serializer handle\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_end_of_list(serializer: *mut ndpi_serializer) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize the start of a block with an unterminated string key\n @param serializer The serializer handle\n @param key The field name or ID\n @param klen The key length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_block_binary(
        _serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
        klen: u_int16_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize the start of a block with a string key\n @param serializer The serializer handle\n @param key The field name or ID\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_start_of_block(
        serializer: *mut ndpi_serializer,
        key: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Serialize the end of a block\n @param serializer The serializer handle\n @param key The field name or ID\n @param value The field value\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serialize_end_of_block(serializer: *mut ndpi_serializer) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the serialized buffer\n @param serializer The serializer handle\n @param buffer_len The buffer length (out)\n @return The buffer"]
    pub fn ndpi_serializer_get_buffer(
        serializer: *mut ndpi_serializer,
        buffer_len: *mut u_int32_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Return the current serialized buffer length\n @param serializer The serializer handle\n @return The buffer length"]
    pub fn ndpi_serializer_get_buffer_len(serializer: *mut ndpi_serializer) -> u_int32_t;
}
extern "C" {
    #[doc = " Return the real internal buffer size (containing the serialized buffer)\n @param serializer The serializer handle\n @return The internal buffer size"]
    pub fn ndpi_serializer_get_internal_buffer_size(serializer: *mut ndpi_serializer) -> u_int32_t;
}
extern "C" {
    #[doc = " Change the serializer buffer length\n @param serializer The serializer handle\n @param l The new buffer length\n @return 0 on success, a negative number otherwise"]
    pub fn ndpi_serializer_set_buffer_len(
        serializer: *mut ndpi_serializer,
        l: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the configured serialization format\n @param serializer The serializer handle\n @return The serialization format"]
    pub fn ndpi_serializer_get_format(
        serializer: *mut ndpi_serializer,
    ) -> ndpi_serialization_format;
}
extern "C" {
    #[doc = " Set the CSV separator\n @param serializer The serializer handle\n @param separator The separator"]
    pub fn ndpi_serializer_set_csv_separator(
        serializer: *mut ndpi_serializer,
        separator: libc::c_char,
    );
}
extern "C" {
    #[doc = " Return the header automatically built from keys (CSV only)\n @param serializer The serializer handle\n @param buffer_len The buffer length (out)\n @return The header"]
    pub fn ndpi_serializer_get_header(
        serializer: *mut ndpi_serializer,
        buffer_len: *mut u_int32_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Create a snapshot of the internal buffer for later rollback (ndpi_serializer_rollback_snapshot)\n @param serializer The serializer handle"]
    pub fn ndpi_serializer_create_snapshot(serializer: *mut ndpi_serializer);
}
extern "C" {
    #[doc = " Rollback to the latest snapshot\n @param serializer The serializer handle"]
    pub fn ndpi_serializer_rollback_snapshot(serializer: *mut ndpi_serializer);
}
extern "C" {
    pub fn ndpi_init_deserializer(
        deserializer: *mut ndpi_serializer,
        serializer: *mut ndpi_serializer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_init_deserializer_buf(
        deserializer: *mut ndpi_serializer,
        serialized_buffer: *mut u_int8_t,
        serialized_buffer_len: u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_get_format(
        _deserializer: *mut ndpi_serializer,
    ) -> ndpi_serialization_format;
}
extern "C" {
    pub fn ndpi_deserialize_get_item_type(
        deserializer: *mut ndpi_serializer,
        key_type: *mut ndpi_serialization_type,
    ) -> ndpi_serialization_type;
}
extern "C" {
    pub fn ndpi_deserialize_next(deserializer: *mut ndpi_serializer) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_key_uint32(
        deserializer: *mut ndpi_serializer,
        key: *mut u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_key_string(
        deserializer: *mut ndpi_serializer,
        key: *mut ndpi_string,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_value_uint32(
        deserializer: *mut ndpi_serializer,
        value: *mut u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_value_uint64(
        deserializer: *mut ndpi_serializer,
        value: *mut u_int64_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_value_int32(
        deserializer: *mut ndpi_serializer,
        value: *mut i32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_value_int64(
        deserializer: *mut ndpi_serializer,
        value: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_value_float(
        deserializer: *mut ndpi_serializer,
        value: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_value_string(
        deserializer: *mut ndpi_serializer,
        value: *mut ndpi_string,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_clone_item(
        deserializer: *mut ndpi_serializer,
        serializer: *mut ndpi_serializer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_deserialize_clone_all(
        deserializer: *mut ndpi_serializer,
        serializer: *mut ndpi_serializer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_alloc_data_analysis(_max_series_len: u_int16_t) -> *mut ndpi_analyze_struct;
}
extern "C" {
    pub fn ndpi_init_data_analysis(s: *mut ndpi_analyze_struct, _max_series_len: u_int16_t);
}
extern "C" {
    pub fn ndpi_free_data_analysis(d: *mut ndpi_analyze_struct, free_pointer: u_int8_t);
}
extern "C" {
    pub fn ndpi_reset_data_analysis(d: *mut ndpi_analyze_struct);
}
extern "C" {
    pub fn ndpi_data_add_value(s: *mut ndpi_analyze_struct, value: u_int32_t);
}
extern "C" {
    pub fn ndpi_data_window_average(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_window_variance(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_window_stddev(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_average(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_entropy(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_variance(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_stddev(s: *mut ndpi_analyze_struct) -> f32;
}
extern "C" {
    pub fn ndpi_data_last(s: *mut ndpi_analyze_struct) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_data_min(s: *mut ndpi_analyze_struct) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_data_max(s: *mut ndpi_analyze_struct) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_data_ratio(sent: u_int32_t, rcvd: u_int32_t) -> f32;
}
extern "C" {
    pub fn ndpi_alloc_rsi(s: *mut ndpi_rsi_struct, num_learning_values: u_int16_t) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_free_rsi(s: *mut ndpi_rsi_struct);
}
extern "C" {
    pub fn ndpi_rsi_add_value(s: *mut ndpi_rsi_struct, value: u_int32_t) -> f32;
}
extern "C" {
    pub fn ndpi_hw_init(
        hw: *mut ndpi_hw_struct,
        num_periods: u_int16_t,
        additive_seeasonal: u_int8_t,
        alpha: f64,
        beta: f64,
        gamma: f64,
        significance: f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_hw_free(hw: *mut ndpi_hw_struct);
}
extern "C" {
    pub fn ndpi_hw_add_value(
        hw: *mut ndpi_hw_struct,
        value: u_int64_t,
        forecast: *mut f64,
        confidence_band: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_ses_init(ses: *mut ndpi_ses_struct, alpha: f64, significance: f32) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_ses_add_value(
        ses: *mut ndpi_ses_struct,
        _value: u_int64_t,
        forecast: *mut f64,
        confidence_band: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_ses_fitting(values: *mut f64, num_values: u_int32_t, ret_alpha: *mut f32);
}
extern "C" {
    pub fn ndpi_des_init(
        des: *mut ndpi_des_struct,
        alpha: f64,
        beta: f64,
        significance: f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_des_add_value(
        des: *mut ndpi_des_struct,
        _value: u_int64_t,
        forecast: *mut f64,
        confidence_band: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_des_fitting(
        values: *mut f64,
        num_values: u_int32_t,
        ret_alpha: *mut f32,
        ret_beta: *mut f32,
    );
}
extern "C" {
    pub fn ndpi_jitter_init(hw: *mut ndpi_jitter_struct, num_periods: u_int16_t) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_jitter_free(hw: *mut ndpi_jitter_struct);
}
extern "C" {
    pub fn ndpi_jitter_add_value(s: *mut ndpi_jitter_struct, value: f32) -> f32;
}
extern "C" {
    pub fn ndpi_data_ratio2str(ratio: f32) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_data_print_window_values(s: *mut ndpi_analyze_struct);
}
extern "C" {
    pub fn ndpi_validate_url(url: *mut libc::c_char) -> ndpi_risk_enum;
}
extern "C" {
    pub fn ndpi_is_protocol_detected(
        ndpi_str: *mut ndpi_detection_module_struct,
        proto: ndpi_protocol,
    ) -> u_int8_t;
}
extern "C" {
    pub fn ndpi_serialize_risk(serializer: *mut ndpi_serializer, risk: ndpi_risk_enum);
}
extern "C" {
    pub fn ndpi_serialize_proto(
        ndpi_struct: *mut ndpi_detection_module_struct,
        serializer: *mut ndpi_serializer,
        risk: ndpi_risk_enum,
        l7_protocol: ndpi_protocol,
    );
}
extern "C" {
    pub fn ndpi_risk2str(risk: ndpi_risk_enum) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_severity2str(s: ndpi_risk_severity) -> *const libc::c_char;
}
extern "C" {
    pub fn ndpi_risk2severity(risk: ndpi_risk_enum) -> *mut ndpi_risk_info;
}
extern "C" {
    pub fn ndpi_risk2score(
        risk: ndpi_risk,
        client_score: *mut u_int16_t,
        server_score: *mut u_int16_t,
    ) -> u_int16_t;
}
extern "C" {
    pub fn ndpi_hll_init(hll: *mut ndpi_hll, bits: u_int8_t) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_hll_destroy(hll: *mut ndpi_hll);
}
extern "C" {
    pub fn ndpi_hll_reset(hll: *mut ndpi_hll);
}
extern "C" {
    pub fn ndpi_hll_add(hll: *mut ndpi_hll, data: *const libc::c_char, data_len: usize);
}
extern "C" {
    pub fn ndpi_hll_add_number(hll: *mut ndpi_hll, value: u_int32_t);
}
extern "C" {
    pub fn ndpi_hll_count(hll: *mut ndpi_hll) -> f64;
}
extern "C" {
    pub fn ndpi_init_bin(b: *mut ndpi_bin, f: ndpi_bin_family, num_bins: u_int16_t) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_free_bin(b: *mut ndpi_bin);
}
extern "C" {
    pub fn ndpi_clone_bin(b: *mut ndpi_bin) -> *mut ndpi_bin;
}
extern "C" {
    pub fn ndpi_inc_bin(b: *mut ndpi_bin, slot_id: u_int16_t, val: u_int32_t);
}
extern "C" {
    pub fn ndpi_set_bin(b: *mut ndpi_bin, slot_id: u_int16_t, value: u_int32_t);
}
extern "C" {
    pub fn ndpi_get_bin_value(b: *mut ndpi_bin, slot_id: u_int16_t) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_reset_bin(b: *mut ndpi_bin);
}
extern "C" {
    pub fn ndpi_normalize_bin(b: *mut ndpi_bin);
}
extern "C" {
    pub fn ndpi_print_bin(
        b: *mut ndpi_bin,
        normalize_first: u_int8_t,
        out_buf: *mut libc::c_char,
        out_buf_len: u_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_bin_similarity(
        b1: *mut ndpi_bin,
        b2: *mut ndpi_bin,
        normalize_first: u_int8_t,
        similarity_max_threshold: f32,
    ) -> f32;
}
extern "C" {
    pub fn ndpi_cluster_bins(
        bins: *mut ndpi_bin,
        num_bins: u_int16_t,
        num_clusters: u_int8_t,
        cluster_ids: *mut u_int16_t,
        centroids: *mut ndpi_bin,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_quick_16_byte_hash(in_16_bytes_long: *mut u_int8_t) -> u_int32_t;
}
extern "C" {
    pub fn ndpi_hash_alloc(max_num_entries: u_int32_t) -> *mut ndpi_str_hash;
}
extern "C" {
    pub fn ndpi_hash_free(h: *mut ndpi_str_hash);
}
extern "C" {
    pub fn ndpi_hash_find_entry(
        h: *mut ndpi_str_hash,
        key: *mut libc::c_char,
        key_len: u_int,
        value: *mut u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_hash_add_entry(
        h: *mut ndpi_str_hash,
        key: *mut libc::c_char,
        key_len: u_int8_t,
        value: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_load_geoip(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip_city_data: *const libc::c_char,
        ip_as_data: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_free_geoip(ndpi_str: *mut ndpi_detection_module_struct);
}
extern "C" {
    pub fn ndpi_get_geoip_asn(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip: *mut libc::c_char,
        asn: *mut u_int32_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_get_geoip_country_continent(
        ndpi_str: *mut ndpi_detection_module_struct,
        ip: *mut libc::c_char,
        country_code: *mut libc::c_char,
        country_code_len: u_int8_t,
        continent: *mut libc::c_char,
        continent_len: u_int8_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ndpi_get_flow_name(flow: *mut ndpi_flow_struct) -> *mut libc::c_char;
}
extern "C" {
    pub fn ndpi_bitmap_alloc() -> *mut ndpi_bitmap;
}
extern "C" {
    pub fn ndpi_bitmap_free(b: *mut ndpi_bitmap);
}
extern "C" {
    pub fn ndpi_bitmap_cardinality(b: *mut ndpi_bitmap) -> u_int64_t;
}
extern "C" {
    pub fn ndpi_bitmap_set(b: *mut ndpi_bitmap, value: u_int32_t);
}
extern "C" {
    pub fn ndpi_bitmap_unset(b: *mut ndpi_bitmap, value: u_int32_t);
}
extern "C" {
    pub fn ndpi_bitmap_isset(b: *mut ndpi_bitmap, value: u_int32_t) -> bool;
}
extern "C" {
    pub fn ndpi_bitmap_clear(b: *mut ndpi_bitmap);
}
extern "C" {
    pub fn ndpi_bitmap_serialize(b: *mut ndpi_bitmap, buf: *mut *mut libc::c_char) -> usize;
}
extern "C" {
    pub fn ndpi_bitmap_deserialize(buf: *mut libc::c_char) -> *mut ndpi_bitmap;
}
extern "C" {
    pub fn ndpi_bitmap_and(a: *mut ndpi_bitmap, b_and: *mut ndpi_bitmap);
}
extern "C" {
    pub fn ndpi_bitmap_or(a: *mut ndpi_bitmap, b_or: *mut ndpi_bitmap);
}
extern "C" {
    pub fn ndpi_bitmap_iterator_alloc(b: *mut ndpi_bitmap) -> *mut ndpi_bitmap_iterator;
}
extern "C" {
    pub fn ndpi_bitmap_iterator_free(b: *mut ndpi_bitmap);
}
extern "C" {
    pub fn ndpi_bitmap_iterator_next(i: *mut ndpi_bitmap_iterator, value: *mut u32) -> bool;
}
